1
00:00:00,090 --> 00:00:02,500
Konten berikut diberikan
di bawah lisensi

2
00:00:02,500 --> 00:00:04,019
Creative Commons.

3
00:00:04,019 --> 00:00:06,360
Dukungan Anda akan membantu
MIT OpenCourseWare

4
00:00:06,360 --> 00:00:10,730
untuk terus menyediakan bahan edukasi
berkualitas tinggi secara gratis

5
00:00:10,730 --> 00:00:13,330
Untuk berdonasi, atau
melihat materi tambahan

6
00:00:13,330 --> 00:00:17,236
dari ratusan kuliah MIT,
kunjungi MIT OpenCourseWare

7
00:00:17,236 --> 00:00:17,861
di ocw.mit.edu.

8
00:00:21,222 --> 00:00:23,180
SRINIVAS DEVADAS: Baiklah,
mari kita mulai.

9
00:00:23,180 --> 00:00:24,740
Selamat pagi semuanya.

10
00:00:24,740 --> 00:00:28,210
Saya melihat banyak wajah letih.

11
00:00:28,210 --> 00:00:29,030
Saya tidak letih.

12
00:00:29,030 --> 00:00:29,930
Mengapa kalian letih?

13
00:00:29,930 --> 00:00:30,894
[TERTAWA]

14
00:00:31,860 --> 00:00:33,130
Saya hanya mengajar paruh waktu.

15
00:00:33,130 --> 00:00:36,240
Kalian semua mengambil
kelas penuh waktu.

16
00:00:36,240 --> 00:00:41,640
Jadi kuliah hari ini adalah
tentang fungsi hash.

17
00:00:41,640 --> 00:00:45,680
Dan Anda mungkin tahu banyak
tentang fungsi hash,

18
00:00:45,680 --> 00:00:47,860
dan mungkin memang demikian.

19
00:00:47,860 --> 00:00:50,840
Tapi yang akan kita lakukan hari
ini adalah membicarakan tentang

20
00:00:50,840 --> 00:00:54,990
aplikasi fungsi hash yang
sangat berbeda,

21
00:00:54,990 --> 00:00:57,700
dan properti-properti baru
di mana kita

22
00:00:57,700 --> 00:01:00,190
akan membutuhkan
fungsi hash yang

23
00:01:00,190 --> 00:01:01,900
akan saya elaborasi lebih lanjut.

24
00:01:01,900 --> 00:01:04,459
Dan kita akan melihat
bermacam-macam aplikasi 

25
00:01:04,459 --> 00:01:06,700
untuk melindungi
password,

26
00:01:06,700 --> 00:01:10,220
memeriksa integritas
file-file, lelang,

27
00:01:10,220 --> 00:01:11,316
dan lain-lain.

28
00:01:11,316 --> 00:01:12,940
Jadi ini akan merupakan
kuliah yang sedikit berbeda.

29
00:01:12,940 --> 00:01:15,692
Hari ini dan Kamis
saya akan

30
00:01:15,692 --> 00:01:18,320
membahas kriptografi
dan aplikasinya,

31
00:01:18,320 --> 00:01:20,380
tidak terlalu banyak algoritme.

32
00:01:20,380 --> 00:01:22,960
Tetapi kita akan melakukan sedikit
analisis yang berkaitan

33
00:01:22,960 --> 00:01:25,390
dengan apakah properti-
propertinya dipenuhi

34
00:01:25,390 --> 00:01:28,010
dalam kasus ini oleh
fungsi hash atau tidak.

35
00:01:28,010 --> 00:01:29,910
Karena itu mari kita mulai melihatnya.

36
00:01:29,910 --> 00:01:33,240
Anda semua tahu
fungsi hash itu apa.

37
00:01:33,240 --> 00:01:37,380
Tidak ada perubahan berarti
pada definisinya.

38
00:01:37,380 --> 00:01:39,370
Tetapi jenis fungsi hash
yang akan kita

39
00:01:39,370 --> 00:01:41,960
lihat hari ini sedikit
berbeda

40
00:01:41,960 --> 00:01:45,590
dari fungsi hash sederhana,
seperti mengambil sisa pembagian

41
00:01:45,590 --> 00:01:49,950
dengan bilangan prima
yang sudah kita lihat sebelumnya.

42
00:01:49,950 --> 00:01:51,680
Dan istilah "collisions"
(tabrakan) akan

43
00:01:51,680 --> 00:01:53,980
muncul lagi,
kecuali bahwa kita

44
00:01:53,980 --> 00:01:56,600
akan meningkatkan
pertaruhannya nya sedikit.

45
00:01:56,600 --> 00:02:04,100
Jadi sebuah fungsi hash
memetakan

46
00:02:04,100 --> 00:02:08,539
string acak-- Saya perbaiki dulu.

47
00:02:11,940 --> 00:02:15,645
Jadi Anda tidak membuat pernyataan
tentang panjang string.

48
00:02:18,440 --> 00:02:23,490
Anda akan akan memecahnya, bahkan jika
Anda memiliki string dengan panjang 512,

49
00:02:23,490 --> 00:02:28,830
atau mungkin panjangnya 27, Anda
ingin mendapatkan sebuah bilangan darinya.

50
00:02:28,830 --> 00:02:31,540
Dalam rentang
spesifik yang

51
00:02:31,540 --> 00:02:34,190
merupakan sebuah kumpulan
bit-bit yang terasosiasi

52
00:02:34,190 --> 00:02:35,346
dengan fungsi hash kita.

53
00:02:35,346 --> 00:02:36,970
Dan sebelumnya kita
memiliki slot-slot

54
00:02:36,970 --> 00:02:39,620
yang terasosiasi dengan keluaran
dari fungsi hash.

55
00:02:39,620 --> 00:02:42,100
Tetapi masukannya
bisa bermacam-macam.

56
00:02:42,100 --> 00:02:48,080
Dan data dalam
bentuk string ini

57
00:02:48,080 --> 00:02:50,310
akan dipetakan, seperti yang
saya katakan barusan,

58
00:02:50,310 --> 00:02:53,190
ke dalam keluaran yang panjangnya konstan.

59
00:02:56,282 --> 00:02:57,990
Dan kita akan berpikir
tentang panjang

60
00:02:57,990 --> 00:03:01,590
yang konstan ini sebagai
jumlah bit,

61
00:03:01,590 --> 00:03:04,530
sebagai pengganti dari slot-slot
pada tabel hash.

62
00:03:04,530 --> 00:03:08,170
Karena kita tidak akan
benar-benar menyimpan

63
00:03:08,170 --> 00:03:10,520
kamus atau tabel hash
di dalam aplikasi

64
00:03:10,520 --> 00:03:11,780
yang akan kita lihat hari ini.

65
00:03:11,780 --> 00:03:14,750
Ini sekedar pertanyaan
soal menghitung sebuah hash.

66
00:03:14,750 --> 00:03:18,120
Dan karena panjang
keluarannya

67
00:03:18,120 --> 00:03:23,880
akan berkisar antara orde
160-bit atau 256-bit,

68
00:03:23,880 --> 00:03:26,980
tidak mungkin Anda dapat
menyimpan dua array

69
00:03:26,980 --> 00:03:33,370
ke 160 elemen pada tabel hash,
atau bahkan dua array ke 64

70
00:03:33,370 --> 00:03:34,340
begitu.

71
00:03:34,340 --> 00:03:37,120
Jadi kita hanya akan
mengasumsikan

72
00:03:37,120 --> 00:03:41,880
bahwa kita menghitung
hash-hash ini

73
00:03:41,880 --> 00:03:45,960
dan menggunakannya untuk
aplikasi tertentu.

74
00:03:45,960 --> 00:03:48,800
Saya baru saja menulis keluarannya
dua kali sepertinya.

75
00:03:48,800 --> 00:03:52,720
Jadi petakan ke
keluaran dengan panjang konstan.

76
00:03:52,720 --> 00:03:58,990
Kita ingin melakukannya
dengan cara yang deterministik.

77
00:03:58,990 --> 00:04:04,430
Jadi setelah kita menghitung
hash dari sebuah

78
00:04:04,430 --> 00:04:07,960
string acak yang
diberikan ke kita, kita ingin

79
00:04:07,960 --> 00:04:10,150
bisa mengulang proses
tersebut untuk mendapatkan

80
00:04:10,150 --> 00:04:13,090
hash yang sama setiap kali.

81
00:04:13,090 --> 00:04:15,070
Kita ingin melakukannya
secara publik.

82
00:04:15,070 --> 00:04:16,170
Jadi semuanya ini publik.

83
00:04:16,170 --> 00:04:17,420
Tidak ada yang dirahasiakan.

84
00:04:17,420 --> 00:04:19,920
Ada fungsi hash berkunci
yang tidak akan

85
00:04:19,920 --> 00:04:22,210
kita lihat hari ini,
tetapi mungkin saat melewatinya

86
00:04:22,210 --> 00:04:24,500
Saya akan menyebutkannya di lain waktu.

87
00:04:24,500 --> 00:04:26,700
Kita tidak akan melihat fungsi hash
berkunci hari ini.

88
00:04:26,700 --> 00:04:30,920
Tidak ada rahasia dalam
deskripsi algoritme

89
00:04:30,920 --> 00:04:34,540
atau teknik yang akan
saya jelaskan hari ini.

90
00:04:34,540 --> 00:04:37,720
Dan kita ingin ini acak.

91
00:04:37,720 --> 00:04:39,870
Kita ingin ini terlihat acak.

92
00:04:39,870 --> 00:04:43,750
Keacakan sejati akan sulit
untuk dicapai,

93
00:04:43,750 --> 00:04:45,142
dengan batasan yang kita miliki.

94
00:04:45,142 --> 00:04:46,850
Tapi kita akan mencoba
dan mengaproksimasinya.

95
00:04:46,850 --> 00:04:48,880
dengan acak-semu (pseudo-randomness).

96
00:04:48,880 --> 00:04:51,040
Tetapi kita ingin
itu terlihat acak, karena kita

97
00:04:51,040 --> 00:04:55,210
tertarik-- sama seperti
dalam kasus kamus

98
00:04:55,210 --> 00:04:58,030
dan aplikasi reguler
dari fungsi hash-- kita

99
00:04:58,030 --> 00:05:00,870
tertarik dalam
meniminalisasi tabrakan.

100
00:05:00,870 --> 00:05:03,570
Dan sebenarnya kita akan
menaikkan per taruhannya sangat tinggi

101
00:05:03,570 --> 00:05:05,470
berkaitan dengan tabrakan.

102
00:05:05,470 --> 00:05:09,870
Kita ingin supaya mustahil
bagi Anda, atau bagi yang lain,

103
00:05:09,870 --> 00:05:12,210
untuk menemukan tabrakan.

104
00:05:12,210 --> 00:05:15,150
Dan itu akan menjadi properti
yang penting tentang collision

105
00:05:15,150 --> 00:05:20,520
resistance (anti-tabrakan) yang tentu
saja membutuhkan sifat acak.

106
00:05:20,520 --> 00:05:24,220
Dan itu adalah
ketiga hal yang kita inginkan:

107
00:05:24,220 --> 00:05:26,840
deterministik, publik,
dan acak.

108
00:05:26,840 --> 00:05:32,870
Jadi dari sudut pandang
deskripsi fungsi

109
00:05:32,870 --> 00:05:35,800
Anda punya 0, 1 bintang di sini,
yang mengimplikasikan bahwa itu

110
00:05:35,800 --> 00:05:37,770
adalah panjang kekuatan yang bisa bervariasi.

111
00:05:37,770 --> 00:05:41,830
Dan kita ingin 0, 1, d.

112
00:05:41,830 --> 00:05:43,955
Dan ini adalah
string dengan panjang d.

113
00:05:49,170 --> 00:05:51,250
Jadi ini berarti bahwa Anda
akan mendapatkan d-bits keluar

114
00:05:51,250 --> 00:05:52,650
dari fungsi hash Anda.

115
00:05:52,650 --> 00:05:56,630
Dan di sini panjangnya
lebih besar atau sama dengan 0.

116
00:06:00,360 --> 00:06:01,750
Begitu.

117
00:06:01,750 --> 00:06:05,000
Tidak ada yang baru di sini.

118
00:06:05,000 --> 00:06:08,880
Tapi ada beberapa hal yang akan
sedikit berbeda.

119
00:06:08,880 --> 00:06:11,630
Dan ada beberapa kerumitan
di sini yang akan kita bahas.

120
00:06:11,630 --> 00:06:18,600
Saya ingin menggaris bawahi dua hal,
satunya yang baru saja saya katakan.

121
00:06:18,600 --> 00:06:23,570
Tidak ada rahasia, tidak ada
kunci rahasia di sini di fungsi hash

122
00:06:23,570 --> 00:06:25,350
yang akan kita deskripsikan.

123
00:06:25,350 --> 00:06:27,250
Seluruh operasi sifatnya publik.

124
00:06:27,250 --> 00:06:33,330
Jadi seperti fungsi
hash Anda, yaitu k mod p

125
00:06:33,330 --> 00:06:38,220
dan p adalah bilangan prima dan
p publik dan diketahui semua pihak

126
00:06:38,220 --> 00:06:40,600
yang menggunakan kamus,
semuanya

127
00:06:40,600 --> 00:06:42,570
yang akan kita bicarakan
adalah publik.

128
00:06:42,570 --> 00:06:44,680
Sehingga siapapun dapat menghitung h.

129
00:06:51,942 --> 00:06:53,400
Dan kita akan mengasumsikan
bahwa ini

130
00:06:53,400 --> 00:06:57,310
adalah komputasi dengan waktu polinomial--
tidak terlalu mengejutkan-- tetapi saya

131
00:06:57,310 --> 00:07:01,700
fleksibel di sini.

132
00:07:01,700 --> 00:07:03,720
Saat Anda melihat kamus,
dan Anda

133
00:07:03,720 --> 00:07:07,140
berpikir tentang menggunakan kamus,
dan menggunakannya untuk mengimplementasikan

134
00:07:07,140 --> 00:07:10,540
algoritme yang efisien,
apa asumsi

135
00:07:10,540 --> 00:07:13,690
yang kita buat secara implisit--
atau mungkin secara eksplisit

136
00:07:13,690 --> 00:07:18,810
di kasus-kasus tertentu-- berkaitan
dengan menghitung hash?

137
00:07:18,810 --> 00:07:19,310
Siapapun?

138
00:07:22,210 --> 00:07:22,710
Ya?

139
00:07:22,710 --> 00:07:23,690
AUDIENS: Waktu yang konstan?

140
00:07:23,690 --> 00:07:25,023
SRINIVAS DEVADAS: Waktu konstan.

141
00:07:25,023 --> 00:07:33,680
Kita asumsikan-- jadi ini tidak
selalu orde 1, ya kan?

142
00:07:33,680 --> 00:07:34,840
Jadi itu penting.

143
00:07:34,840 --> 00:07:42,180
Kita akan-- Saya ingin
memastikan Anda semua menyaksikan.

144
00:07:42,180 --> 00:07:45,770

145
00:07:45,770 --> 00:07:47,990
kompleksitas hash nya.

146
00:07:47,990 --> 00:07:50,459
Dan seperti yang akan Anda lihat,
karena properti yang diinginkan,

147
00:07:50,459 --> 00:07:51,750
kita akan melakukan hal tersebut.

148
00:07:51,750 --> 00:07:54,010
Kita akan meminta banyak hal
berkaitan dengan

149
00:07:54,010 --> 00:07:55,610
fungsi-fungsi hash ini.

150
00:07:55,610 --> 00:07:58,350
Tidak siapapun dapat
menemukan tabrakan, ya kan?

151
00:07:58,350 --> 00:08:01,750
Dan jika Anda punya sesuatu
sesederhana k mod p,

152
00:08:01,750 --> 00:08:03,910
akan sangat mudah untuk
menemukan tabrakan.

153
00:08:03,910 --> 00:08:06,710
Maka fungsi hash
orde 1 ini

154
00:08:06,710 --> 00:08:08,380
yang Anda sudah
kenal tidak akan

155
00:08:08,380 --> 00:08:12,160
mendapatkan nilai berkaitan
dengan properti manapun

156
00:08:12,160 --> 00:08:14,500
dari yang akan kita bahas
sebentar lagi.

157
00:08:14,500 --> 00:08:16,962
Baik, jadi ingatlah bahwa ini
adalah komputasi dengan waktu polinomial

158
00:08:16,962 --> 00:08:19,170
Dan ada banyak contoh
dari fungsi hash ini

159
00:08:19,170 --> 00:08:21,820
Dan untuk kalian yang
tertarik ke bidang keamanan komputer

160
00:08:21,820 --> 00:08:24,890
dan kriptografi,
kalian mungkin sudah pernah dengar

161
00:08:24,890 --> 00:08:29,240
tentang MD4 dan MD5 misalnya.

162
00:08:29,240 --> 00:08:30,260
Ini adalah versi-versi.

163
00:08:30,260 --> 00:08:32,309
MD singkatan dari Message Digest.

164
00:08:32,309 --> 00:08:35,610
Ini merupakan fungsi yang
diciptakan oleh Profesor Rivest.

165
00:08:35,610 --> 00:08:42,970
Dan mereka memiliki d sama dengan
128 saat itu-- 1992,

166
00:08:42,970 --> 00:08:45,830
seingat saya-- ketika
mereka pertama kali diusulkan.

167
00:08:45,830 --> 00:08:50,830
Dan algoritma-algoritma ini telah
rusak sejak itu dalam arti

168
00:08:50,830 --> 00:08:53,490
telah diduga bahwa
mereka mempunyai properti tertentu

169
00:08:53,490 --> 00:08:59,060
mengenai ketahanan terhadap kesamaan (collision resistance) yang
membutuhkan waktu eksponensial

170
00:08:59,060 --> 00:09:01,660
bagi siapapun untuk menemukan collision.

171
00:09:01,660 --> 00:09:04,490
Dan membutuhkan waktu
masih eksponensial,

172
00:09:04,490 --> 00:09:11,040
tapi 2 pangkat 37 adalah
eksponensial pada tingkatan tertentu,

173
00:09:11,040 --> 00:09:13,700
tapi konstan pada tingkatan yang lain.

174
00:09:13,700 --> 00:09:17,720
Jadi Anda dapat melakukannya
dalam beberapa detik sekarang.

175
00:09:17,720 --> 00:09:20,610
Jadi sedikit sejarah.

176
00:09:20,610 --> 00:09:23,300
Saya tidak akan menghabiskan
banyak waktu mengenai hal ini.

177
00:09:23,300 --> 00:09:28,400
MD5 digunakan untuk menciptakan apa yang
disebut sebuah algoritma hash yang aman.

178
00:09:28,400 --> 00:09:31,770
Ini adalah 160-bit.

179
00:09:31,770 --> 00:09:36,330
Dan belum cukup 
rusak (tidak aman) saat ini.

180
00:09:36,330 --> 00:09:41,920
Tapi orang-orang menganggapnya
rusak, atau akan segera rusak.

181
00:09:41,920 --> 00:09:45,560
Sekarang, algoritme
yang direkomendasikan

182
00:09:45,560 --> 00:09:50,260
disebut SHA-3, secure hash
algorithm versi tiga.

183
00:09:50,260 --> 00:09:53,870
Dan ada sebuah kontes
yang berlangsung selama 18 bulan,

184
00:09:53,870 --> 00:09:56,770
atau mungkin bahkan lebih lama,
yang pada akhirnya dimenangkan

185
00:09:56,770 --> 00:09:59,580
oleh sesuatu yang sekarang menjadi SHA-3.

186
00:09:59,580 --> 00:10:03,200
Dan mereka mempunyai nama yang berbeda
untuknya yang tidak saya ingat.

187
00:10:03,200 --> 00:10:05,180
Tapi itu berubah menjadi SHA-3.

188
00:10:05,180 --> 00:10:08,220
Dan apa yang terjadi sepanjang 
jalan, saat kita berganti dari MD4,

189
00:10:08,220 --> 00:10:12,690
MD5, SHA-1 ke SHA-3, adalah
jumlah komputasi

190
00:10:12,690 --> 00:10:14,810
yang harus Anda lakukan meningkat.

191
00:10:14,810 --> 00:10:16,570
Dan kompleksitas dari
operasi yang Anda

192
00:10:16,570 --> 00:10:21,690
harus lakukan untuk menghitung
hash dari sebuah string acak

193
00:10:21,690 --> 00:10:24,460
meningkat sampai ke
suatu titik dimana-- Anda

194
00:10:24,460 --> 00:10:27,720
akan berpikir ini adalah
100 ronde komputasi.

195
00:10:27,720 --> 00:10:31,780
Dan tentunya 
komputasi orde d,

196
00:10:31,780 --> 00:10:34,200
di mana d adalah jumlah bit.

197
00:10:34,200 --> 00:10:35,940
Dan bahkan mungkin lebih.

198
00:10:35,940 --> 00:10:38,850
Jadi sudah pasti bukan orde 1.

199
00:10:38,850 --> 00:10:43,270
Jadi seperti yang saya katakan sedikit
tentang konteks

200
00:10:43,270 --> 00:10:45,355
terhadap hal-hal yang
ada di luar sana.

201
00:10:45,355 --> 00:10:46,980
Pada akhir perkuliahan
saya akan memberikan kalian

202
00:10:46,980 --> 00:10:49,570
gambaran tentang bagaimana
fungsi hash ini dibuat.

203
00:10:49,570 --> 00:10:51,380
Kita tidak akan
menghabiskan banyak waktu

204
00:10:51,380 --> 00:10:53,220
untuk membuat
fungsi hash ini.

205
00:10:53,220 --> 00:10:56,320
Ini sesungguhnya sebuah topik penelitian
tersendiri dan bukan 

206
00:10:56,320 --> 00:10:58,390
dalam cakupan 6.046.

207
00:10:58,390 --> 00:11:00,920
Apa yang ada dalam cakupan
6.046, dan apa

208
00:11:00,920 --> 00:11:02,510
yang saya rasa lebih
menarik, itulah

209
00:11:02,510 --> 00:11:05,690
hal yang akan kita berikan fokus
dengan usaha dan waktu kita,

210
00:11:05,690 --> 00:11:07,990
adalah properti dari
fungsi-fungsi hash ini.

211
00:11:07,990 --> 00:11:10,640
Dan mengapa properti ini
bermanfaat dalam berbagai

212
00:11:10,640 --> 00:11:12,270
aplikasi yang berbeda.

213
00:11:12,270 --> 00:11:15,100
Jadi apa yang kita inginkan?

214
00:11:15,100 --> 00:11:19,440
Kita ingin sebuah pembangkit nilai acak.

215
00:11:19,440 --> 00:11:23,790
Kita pada dasarnya ingin
membangun sesuatu

216
00:11:23,790 --> 00:11:27,960
yang terlihat seperti itu,
deterministik, publik, acak.

217
00:11:27,960 --> 00:11:31,390
Dan kita akan 
mengklaim bahwa hal yang kita inginkan

218
00:11:31,390 --> 00:11:33,135
adalah sebuah
pembangkit nilai acak yang memiliki semua

219
00:11:33,135 --> 00:11:35,892
properti mengagumkan
yang akan saya deskripsikan.

220
00:11:35,892 --> 00:11:37,850
Saya akan mendeskripsikan
pembangkit nilai acak tersebut kepada Anda,

221
00:11:37,850 --> 00:11:40,391
lalu saya akan memberitahu Anda
apa saja properti-propertinya.

222
00:11:40,391 --> 00:11:44,420
Dan sayangnya,
ini adalah dunia yang ideal

223
00:11:44,420 --> 00:11:47,890
dan kita tidak dapat membangun
hal ini di dunia nyata.

224
00:11:47,890 --> 00:11:49,919
Jadi kita akan
harus memperkirakannya.

225
00:11:49,919 --> 00:11:52,460
Dan di situlah di mana MD4,
MD5, dan SHA-1 berfungsi,

226
00:11:52,460 --> 00:11:55,200
OK?

227
00:11:55,200 --> 00:11:56,885
Jadi ini tidak dapat
dicapai secara praktis.

228
00:12:05,560 --> 00:12:09,300
Jadi apa pembangkit nilai ini?

229
00:12:09,300 --> 00:12:17,170
Pembangkit nilai ini menerima input
x, dimiliki oleh 0,1 bintang.

230
00:12:17,170 --> 00:12:20,740
Jadi hal tersebut bisa merupakan
sebuah string acak.

231
00:12:20,740 --> 00:12:26,100
Jika x tidak ada di buku--
jadi ada sebuah buku ini,

232
00:12:26,100 --> 00:12:26,840
oke?

233
00:12:26,840 --> 00:12:29,720
Dan ada sebuah buku ini
dengan kapasitas tak terhingga

234
00:12:29,720 --> 00:12:35,170
yang berisi semua komputasi
yang pernah dilakukan sebelumnya.

235
00:12:35,170 --> 00:12:36,770
Dan komputasi-komputasi itu selalu 
disimpan di buku tersebut.

236
00:12:36,770 --> 00:12:38,770
Dan itulah bagaimana kita akan
mendapatkan determinisme.

237
00:12:38,770 --> 00:12:42,100
Karena buku ini
sudah terisi dari awal.

238
00:12:42,100 --> 00:12:44,380
Semua catatan di dalam 
buku tersebut dipenuhi

239
00:12:44,380 --> 00:12:47,000
dengan menggunakan keacakan murni.

240
00:12:47,000 --> 00:12:55,610
Jadi Anda melempar koin sebanyak d
kali untuk menentukan h dari x.

241
00:12:55,610 --> 00:12:57,760
Jadi pada dasarnya begitu saja.

242
00:12:57,760 --> 00:12:59,420
Dan Anda terus-menerus melempar koinnya.

243
00:12:59,420 --> 00:13:00,950
Anda harus melempar sebanyak d kali.

244
00:13:00,950 --> 00:13:05,320
Jadi jika x adalah 0, Anda
melempar koinnya sebanyak d kali, d adalah 160.

245
00:13:05,320 --> 00:13:08,300
Anda melempar koin 160
kali dan mendapatkan sebuah string.

246
00:13:08,300 --> 00:13:13,430
Jika x adalah 1, lempar 160 kali,
Anda mendapatkan string yang berbeda

247
00:13:13,430 --> 00:13:15,530
dengan kemungkinan
yang sangat tinggi, jelas.

248
00:13:15,530 --> 00:13:16,890
Dan seterusnya.

249
00:13:16,890 --> 00:13:19,280
Tapi hal yang Anda lakukan adalah
Anda mempunyai buku ini.

250
00:13:19,280 --> 00:13:29,870
Jadi Anda akan mencatat
x h dari x di dalam buku tersebut, OK?

251
00:13:29,870 --> 00:13:31,770
Jadi pada tingkat tertentu
fungsi hash Anda

252
00:13:31,770 --> 00:13:35,220
merupakan tabel pencari raksasa
di langit, benar?

253
00:13:35,220 --> 00:13:37,480
Sebenarnya bukan raksasa, tapi
tabel pencari dengan kapasitas tak terhingga

254
00:13:37,480 --> 00:13:38,510
di langit.

255
00:13:38,510 --> 00:13:42,230
Karena Anda bisa menaruh
string-string acak ke dalamnya.

256
00:13:42,230 --> 00:13:47,910
Dan jika itu ada di buku tersebut-- 
jelas ini adalah bagian penting

257
00:13:47,910 --> 00:13:52,740
yang memberikan Anda determinisme--
maka Anda keluarkan y,

258
00:13:52,740 --> 00:13:58,700
di mana x dan y ada 
di dalam buku tersebut, OK?

259
00:14:01,350 --> 00:14:05,040
Jadi Anda mendapatkan sebuah
jawaban acak setiap kali,

260
00:14:05,040 --> 00:14:08,380
kecuali sesuai yang dibutuhkan
untuk konsistensi

261
00:14:08,380 --> 00:14:10,180
dengan jawaban-jawaban sebelumnya.

262
00:14:10,180 --> 00:14:11,930
Jadi, pertama kali
Anda melihat sebuah string,

263
00:14:11,930 --> 00:14:16,730
atau-- dan seluruh dunia
dapat membuat buku ini.

264
00:14:16,730 --> 00:14:17,740
Ini publik.

265
00:14:17,740 --> 00:14:22,430
Jadi, jika saya membuat buku tersebut saat
pertama kali dengan sebuah string tertentu,

266
00:14:22,430 --> 00:14:23,710
katakanlah Eric.

267
00:14:23,710 --> 00:14:25,120
Saya adalah string tersebut.

268
00:14:25,120 --> 00:14:29,960
Dan saya adalah orang yang menaruh
masukan tersebut-- x sama dengan Eric

269
00:14:29,960 --> 00:14:34,040
dan h dari x, h dari Eric sama dengan
suatu 160-bit string acak--

270
00:14:34,040 --> 00:14:36,640
ke dalam buku tersebut, saya mendapatkan
penghargaan untuk hal itu, benar?

271
00:14:36,640 --> 00:14:43,650
Tetapi jika Anda datang satu nanodetik
kemudian dan meminta h dari Eric,

272
00:14:43,650 --> 00:14:46,090
Anda seharusnya mendapatkan tepat
apa yang telah ditaruh ke dalam buku tersebut

273
00:14:46,090 --> 00:14:49,850
ketika saya meminta h dari Eric.

274
00:14:49,850 --> 00:14:51,290
Dan seterusnya.

275
00:14:51,290 --> 00:14:53,050
Jadi ini benar untuk semua orang.

276
00:14:53,050 --> 00:14:56,810
Jadi ini seperti-- maksud saya
pada dasarnya mustahil untuk didapatkan.

277
00:14:56,810 --> 00:15:01,770
Karena tidak hanya 
setiap orang dan semua orang bertanya,

278
00:15:01,770 --> 00:15:05,190
Anda harus membuat
urutan ini terasosiasikan

279
00:15:05,190 --> 00:15:09,450
dengan orang-orang yang bertanya ke buku tersebut.

280
00:15:09,450 --> 00:15:11,330
Dan Anda harus
mempunyai konsistensi.

281
00:15:11,330 --> 00:15:11,990
Baik.

282
00:15:11,990 --> 00:15:15,990
Jadi semua orang sudah yakin
bahwa kita tidak dapat membangun ini?

283
00:15:15,990 --> 00:15:16,710
Baik.

284
00:15:16,710 --> 00:15:18,660
Jika Anda mendapatkan apapun
dari perkuliahan ini,

285
00:15:18,660 --> 00:15:20,011
hal itu yang seharusnya Anda dapatkan.

286
00:15:20,011 --> 00:15:20,510
Tidak, tidak.

287
00:15:20,510 --> 00:15:22,290
Ada lebih banyak hal.

288
00:15:22,290 --> 00:15:26,750
Jadi kita ingin memperkirakan
pembangkit nilai acak tersebut.

289
00:15:26,750 --> 00:15:28,840
Dan kita akan membahas hal itu.

290
00:15:28,840 --> 00:15:34,767
Jelas bahwa kita harus melakukan ini
dalam ruang polinomial juga.

291
00:15:34,767 --> 00:15:35,850
Jadi apa yang salah dengan hal ini?

292
00:15:35,850 --> 00:15:38,810
Tentu saja gambaran ini 
Saya tidak benar-benar mengatakan ini,

293
00:15:38,810 --> 00:15:42,320
tetapi Anda ingin hal-hal menjadi
waktu polinomial dalam hal ruang.

294
00:15:42,320 --> 00:15:46,210
Anda tidak ingin menyimpan
angka tak terhingga-- hal ini 

295
00:15:46,210 --> 00:15:48,649
lebih buruk dari waktu polinomial,
lebih buruk dari waktu eksponensial,

296
00:15:48,649 --> 00:15:51,190
karena ini string-string acak
yang sedang kita bicarakan di sini,

297
00:15:51,190 --> 00:15:51,920
benar?

298
00:15:51,920 --> 00:15:53,940
Jadi Anda tidak mungkin melakukan itu.

299
00:15:53,940 --> 00:15:56,350
Jadi kita harus melakukan
sesuatu yang lebih baik.

300
00:15:56,350 --> 00:16:00,180
Tapi sebelum saya masuk ke bagaimana sebenarnya kita
akan membangun ini, dan memberikan 

301
00:16:00,180 --> 00:16:04,346
Anda gambaran tentang bagaimana SHA-1 
dan MD5 dibangun--

302
00:16:04,346 --> 00:16:06,220
dan itu akan kita
bahas nanti--

303
00:16:06,220 --> 00:16:11,910
Saya ingin menghabiskan banyak waktu
pada hal yang menarik,

304
00:16:11,910 --> 00:16:13,630
yaitu properti-properti
yang diinginkan.

305
00:16:13,630 --> 00:16:16,640
Yang dapat Anda lihat dengan
menggunakan pembangkit nilai acak.

306
00:16:16,640 --> 00:16:18,690
Jadi hal yang mengagumkan tentang
pembangkit nilai acak adalah

307
00:16:18,690 --> 00:16:21,140
itu merupakan algoritme yang sederhana.

308
00:16:21,140 --> 00:16:23,060
Anda dapat memahaminya.

309
00:16:23,060 --> 00:16:24,410
Anda tidak dapat mengimplementasikannya.

310
00:16:24,410 --> 00:16:27,130
Namun sekarang Anda dapat melihat
properti-properti mengagumkan apa yang 

311
00:16:27,130 --> 00:16:28,230
diberikan kepada Anda.

312
00:16:28,230 --> 00:16:30,350
Dan properti-properti ini 
akan menjadi penting

313
00:16:30,350 --> 00:16:32,490
untuk aplikasi kita, OK?

314
00:16:32,490 --> 00:16:36,146
Jadi mari kita mulai dengan
berbagai properti-properti yang berbeda.

315
00:16:36,146 --> 00:16:37,520
Dan ini semua merupakan
properti yang

316
00:16:37,520 --> 00:16:43,030
akan berguna untuk
verifikasi atau aplikasi

317
00:16:43,030 --> 00:16:44,850
keamanan komputer.

318
00:16:44,850 --> 00:16:51,100
Yang pertama, bukan ow,
ini adalah O, W. Ini adalah one-wayness (ke-satu-arah-an),

319
00:16:51,100 --> 00:16:51,780
baik?

320
00:16:51,780 --> 00:16:53,930
Jadi satu arah atau ke-satu-arah-an.

321
00:16:53,930 --> 00:17:03,230
Dan hal tersebut juga disebut-- Anda
tidak akan menyebutnya ini--

322
00:17:03,230 --> 00:17:09,390
tetapi mungkin ini merupakan 
istilah yang lebih teknis, istilah yang lebih

323
00:17:09,390 --> 00:17:11,150
tepat, pre-image resistance (ketahanan pre-image).

324
00:17:11,150 --> 00:17:13,060
Jadi apa arti dari ini?

325
00:17:13,060 --> 00:17:15,167
Jadi ini adalah kebutuhan 
yang sangat kuat.

326
00:17:15,167 --> 00:17:16,750
Maksud saya beberapa 
hal yang lain juga

327
00:17:16,750 --> 00:17:18,990
mungkin akan lebih kuat.

328
00:17:18,990 --> 00:17:21,270
Tetapi ini adalah 
kebutuhan yang cukup kuat

329
00:17:21,270 --> 00:17:28,710
yang mengatakan ini
tidak memungkinkan, diberikan y,

330
00:17:28,710 --> 00:17:45,170
yang ada di dalam-- pada dasarnya
sebuah vektor d-bit, untuk menemukan x apapun

331
00:17:45,170 --> 00:17:50,950
sehingga h dari x sama dengan y.

332
00:17:50,950 --> 00:18:00,120
Jadi x ini adalah
pre-image dari y.

333
00:18:00,120 --> 00:18:01,580
Jadi hal ini mengatakan apa?

334
00:18:01,580 --> 00:18:04,400
Hal ini mengatakan bahwa saya ingin
membuat sebuah fungsi hash sehingga

335
00:18:04,400 --> 00:18:08,030
jika saya memberikan Anda 
sebuah spesifik-- kita menyebutnya

336
00:18:08,030 --> 00:18:12,870
string 160-bit, karena
kita berbicara mengenai SHA-1 disini,

337
00:18:12,870 --> 00:18:16,792
dan itu adalah hashnya--
Saya akan memiliki,

338
00:18:16,792 --> 00:18:18,250
ini akan menjadi
tidak mungkin

339
00:18:18,250 --> 00:18:25,430
untuk saya menemukan sebuah x yang
memproduksi string 160-bit tersebut,

340
00:18:25,430 --> 00:18:26,390
OK?

341
00:18:26,390 --> 00:18:29,100
Sekarang jika Anda melihat
pada pembangkit nilai acak kita,

342
00:18:29,100 --> 00:18:32,750
Anda menyadari jika Anda
mempunyai sebuah string 160-bit,

343
00:18:32,750 --> 00:18:36,970
dan mungkin Anda
mempunyai seluruh buku

344
00:18:36,970 --> 00:18:39,290
dan Anda bisa membaca
seluruh buku tersebut.

345
00:18:39,290 --> 00:18:41,940
Itu adalah buku dengan kapasitas tidak terbatas.

346
00:18:41,940 --> 00:18:44,750
Buku itu mempunyai banyak hal di dalamnya.

347
00:18:44,750 --> 00:18:49,800
Dan ketahuilah bahwa setiap kali siapapun
bertanya ke buku untuk pertama kali

348
00:18:49,800 --> 00:18:53,580
untuk sebuah x tertentu, ada
angka 160-bit acak yang

349
00:18:53,580 --> 00:18:55,700
dibangkitkan dan
ditaruh ke dalam buku tersebut.

350
00:18:55,700 --> 00:18:58,100
Dan ada banyak sekali
angka tersebut, benar?

351
00:18:58,100 --> 00:18:59,954
Jadi hal yang akan
terjadi adalah, Anda

352
00:18:59,954 --> 00:19:01,870
harus memeriksa 
keseluruhan buku,

353
00:19:01,870 --> 00:19:04,710
keseluruhan buku yang berpotensi
berkapasitas tidak terbatas ini,

354
00:19:04,710 --> 00:19:13,500
untuk mengetahui apakah
y tertentu ada di dalam buku

355
00:19:13,500 --> 00:19:14,660
atau tidak.

356
00:19:14,660 --> 00:19:18,310
Dan itu mungkin akan membutuhkan waktu 
yang sangat lama, OK?

357
00:19:18,310 --> 00:19:23,290
Jadi pada kasus di mana Anda
memiliki sebuah pembangkit nilai acak Anda

358
00:19:23,290 --> 00:19:27,660
harus menelusuri dan menemukan--
memeriksa keluaran hash

359
00:19:27,660 --> 00:19:30,502
yang sesuai dengan tiap
entri dalam pembangkit nilai acak,

360
00:19:30,502 --> 00:19:32,960
Anda akan mulai mencocokkan,
cocokkan, cocokkan, cocokkan, cocokkan,

361
00:19:32,960 --> 00:19:35,290
hal itu akan membutuhkan
waktu eksponensial.

362
00:19:35,290 --> 00:19:37,760
Sebenarnya lebih buruk dari itu,
mempertimbangkan kapasitas tak terhingga

363
00:19:37,760 --> 00:19:38,930
dari buku tersebut.

364
00:19:38,930 --> 00:19:40,970
Jadi hal ini dengan jelas memberikan Anda hal itu.

365
00:19:40,970 --> 00:19:44,070
Sekarang Anda mungkin tidak sepenuhnya
puas dengan jawaban itu

366
00:19:44,070 --> 00:19:46,620
karena Anda mengatakan,
Anda tidak dapat mengimplementasikan hal itu.

367
00:19:46,620 --> 00:19:48,410
Tapi kita akan membahasnya
sedikit, seperti yang saya katakan,

368
00:19:48,410 --> 00:19:50,410
tentang bagaimana Anda dapat
memperoleh ini sesungguhnya.

369
00:19:50,410 --> 00:19:54,510
Tapi apa yang-- saya harus
jelas-- adalah fungsi hash

370
00:19:54,510 --> 00:19:59,180
sederhana yang telah kita lihat
sebelumnya hanya untuk membangun

371
00:19:59,180 --> 00:20:02,570
kamus tidak
memmuaskan hal ini, benar?

372
00:20:02,570 --> 00:20:11,860
Jadi misalkan saya mempunyai h dari x
sama dengan x kuadrat modulo p.

373
00:20:11,860 --> 00:20:18,050
Apakah ini satu arah,
diberikan sebuah p publik?

374
00:20:18,050 --> 00:20:19,210
Tidak tentu saja bukan, benar?

375
00:20:19,210 --> 00:20:22,310
Karena saya akan menjadi--
hal ini akan mudah

376
00:20:22,310 --> 00:20:24,730
bagi saya untuk melakukan sesuatu.

377
00:20:24,730 --> 00:20:29,320
Walaupun hal ini adalah aritmatika
diskret saya dapat melakukan sesuatu

378
00:20:29,320 --> 00:20:32,670
seperti, yah, saya tahu bahwa apa yang
saya punya di sini-- sebenarnya, mari

379
00:20:32,670 --> 00:20:34,170
kita lakukan dengan sesuatu 
yang lebih sederhana,

380
00:20:34,170 --> 00:20:36,580
lalu saya akan membahas
tentang x kuadrat.

381
00:20:36,580 --> 00:20:38,650
Jika saya memiliki sesuatu
se-sederhana x modulo p,

382
00:20:38,650 --> 00:20:42,100
maksud saya itu secara sepele rusak
dipandang dari ke-satu-arah-an.

383
00:20:42,100 --> 00:20:45,900
Karena saya tahu bahwa h dari x bisa
dilihat sebagai sisa.

384
00:20:45,900 --> 00:20:51,870
Jadi apapun-- jika ini
adalah h dari x, dan mari

385
00:20:51,870 --> 00:20:54,310
sebut saja hal itu y
sebentar, karena hal itu 

386
00:20:54,310 --> 00:20:56,280
apa yang kita punya di sana.

387
00:20:56,280 --> 00:21:00,340
Sesuatu yang merupakan kelipatan
dari y ditambah sisanya-- jadi saya

388
00:21:00,340 --> 00:21:02,777
bisa memiliki a-- apakah itu benar?

389
00:21:02,777 --> 00:21:03,610
Apakah itu yang saya inginkan?

390
00:21:03,610 --> 00:21:04,109
Iya.

391
00:21:04,109 --> 00:21:05,050
Tidak, tambah y.

392
00:21:05,050 --> 00:21:13,760
Jadi saya ingin a dari-- jadi karena
saya tidak bisa mengetahui hal itu,

393
00:21:13,760 --> 00:21:16,250
kenapa Anda tidak bisa?

394
00:21:16,250 --> 00:21:17,970
Apa yang harus saya
taruh di sana agar

395
00:21:17,970 --> 00:21:24,170
bisa menemukan sebuah x yang
akan menghasilkan sebuah y?

396
00:21:24,170 --> 00:21:25,290
Apakah saya bisa menulis sebuah persamaan?

397
00:21:25,290 --> 00:21:26,192
Iya?

398
00:21:26,192 --> 00:21:27,967
AUDIENS: Bisakah Anda
menulis y nya saja?

399
00:21:27,967 --> 00:21:29,300
SRINIVAS DEVADAS: Hanya y nya saja.

400
00:21:29,300 --> 00:21:29,960
Itu benar.

401
00:21:29,960 --> 00:21:30,900
Poin yang baik.

402
00:21:30,900 --> 00:21:32,635
Hanya y nya saja dalam kasus ini.

403
00:21:32,635 --> 00:21:33,820
Bagus.

404
00:21:33,820 --> 00:21:35,650
Saya tahu kalian lebih
pintar dari saya.

405
00:21:35,650 --> 00:21:38,060
Hal ini membuktikannya.

406
00:21:38,060 --> 00:21:41,500
Jadi, jika Anda hanya mengambil
y-- dan ingat y

407
00:21:41,500 --> 00:21:46,190
akan menjadi sesuatu
yang bernilai dari 0 sampai p dikurangi 1, benar?

408
00:21:46,190 --> 00:21:47,520
Dan begitu saja.

409
00:21:47,520 --> 00:21:49,170
Hal itu hanya akan berlalu saja, benar?

410
00:21:49,170 --> 00:21:51,150
Jadi itu adalah contoh yang
mudah dipahami, benar?

411
00:21:51,150 --> 00:21:55,780
Sekarang jika saya memasukkan x kuadrat
di sini, jelas ini bukan y,

412
00:21:55,780 --> 00:22:03,050
tetapi saya bisa mulai 
melihat pada-- hal yang saya miliki di sini

413
00:22:03,050 --> 00:22:05,280
saya akan mendapatkan y yang
terlihat seperti x kuadrat.

414
00:22:05,280 --> 00:22:07,220
Tapi saya bisa mengambil
y yang saya miliki,

415
00:22:07,220 --> 00:22:09,240
mengambil akar kuadrat
dari y tersebut, lalu mulai

416
00:22:09,240 --> 00:22:13,570
mencari nilai-nilai x yang memberikan
saya y yang saya miliki.

417
00:22:13,570 --> 00:22:18,020
Sebenarnya ini bukan proses 
yang rumit untuk dicoba dan dipelajari,

418
00:22:18,020 --> 00:22:20,230
melalui coba-coba
(trial and error),

419
00:22:20,230 --> 00:22:23,250
x apakah yang
menghasilkan sebuah y tertentu

420
00:22:23,250 --> 00:22:25,360
untuk jenis-jenis fungsi
hash yang telah kita

421
00:22:25,360 --> 00:22:26,900
lihat, OK?

422
00:22:26,900 --> 00:22:32,050
Sekarang semakin Anda membuat rumit
persamaan ini, persamaan ini semakin sulit.

423
00:22:32,050 --> 00:22:34,626
Karena Anda harus membalikkan
kumpulan persamaan ini.

424
00:22:34,626 --> 00:22:36,000
Dan seperti itulah
permainan ini akan berbentuk

425
00:22:36,000 --> 00:22:38,620
pada saat Anda membuat
fungsi hash satu arah.

426
00:22:38,620 --> 00:22:41,520
Jumlah komputasi
yang Anda lakukan untuk

427
00:22:41,520 --> 00:22:44,770
menghitung nilai y yang
akan meningkat sampai ke titik

428
00:22:44,770 --> 00:22:47,770
di mana, seperti yang saya katakan, Anda mempunyai
80, 100 ronde komputasi,

429
00:22:47,770 --> 00:22:49,400
hal-hal dicampur aduk.

430
00:22:49,400 --> 00:22:53,210
Dan harapannya adalah Anda menciptakan
sirkuit ini,

431
00:22:53,210 --> 00:22:54,970
yang memiliki semua
komputasi ini di dalamnya.

432
00:22:54,970 --> 00:22:57,170
Ke depannya akan semakin
mudah, karena Anda telah

433
00:22:57,170 --> 00:22:59,350
menspesifikasikan
perkalian-perkaliannya dan modulo-modulonya

434
00:22:59,350 --> 00:23:00,700
dan sebagainya.

435
00:23:00,700 --> 00:23:04,830
Tapi tidak semua operasi-operasi ini
memiliki invers-invers sederhana.

436
00:23:04,830 --> 00:23:07,790
Dan kembali ke belakang,
apa yang

437
00:23:07,790 --> 00:23:11,010
harus Anda lakukan untuk
mematahkan ke-satu-arah-an,

438
00:23:11,010 --> 00:23:14,890
atau menemukan x
dari suatu y, akan

439
00:23:14,890 --> 00:23:17,100
menjadi semakin sulit
seiring dengan komputasi-komputasi yang

440
00:23:17,100 --> 00:23:18,890
semakin kompleks, OK?

441
00:23:18,890 --> 00:23:20,905
Jadi semua orang memiliki gambaran
tentang apa itu ke-satu-arah-an?

442
00:23:24,810 --> 00:23:26,990
Jadi itulah ke-satu-arah-an.

443
00:23:26,990 --> 00:23:30,930
Ada empat properti lain,
dua dari mereka sangat berhubungan.

444
00:23:30,930 --> 00:23:33,700
CR dan TCR.

445
00:23:33,700 --> 00:23:35,550
Jadi CR adalah ketahanan terhadap tabrakan (collision resistance).

446
00:23:42,970 --> 00:23:54,290
Hal ini tidak memungkinkan untuk menemukan x dan
x aksen, agar x tidak sama

447
00:23:54,290 --> 00:24:02,269
dengan x aksen, dan h dari
x sama dengan h dari x aksen,

448
00:24:02,269 --> 00:24:03,560
yang tentu saja merupakan sebuah tabrakan.

449
00:24:08,300 --> 00:24:09,690
OK?

450
00:24:09,690 --> 00:24:14,790
Dan itu hanya menyatakan Anda memiliki
fungsi hash gila ini di mana

451
00:24:14,790 --> 00:24:16,650
Anda tidak dapat menemukan collisions.

452
00:24:16,650 --> 00:24:18,620
Yah ini akan menjadi
sangat luar biasa.

453
00:24:18,620 --> 00:24:21,740
Sebenarnya hal itulah yang kita inginkan
ketika kita membangun kamus-kamus.

454
00:24:21,740 --> 00:24:25,290
Tapi kenapa kita tidak menggunakan
SHA-3 dalam kamus-kamus?

455
00:24:28,410 --> 00:24:30,350
Kenapa kita tidak menggunakan
SHA-3 dalam kamus-kamus?

456
00:24:30,350 --> 00:24:30,851
Ya?

457
00:24:30,851 --> 00:24:33,058
AUDIENS: Karena hal tersebut lebih
rumit dari yang kita butuhkan.

458
00:24:33,058 --> 00:24:35,270
SRINIVAS DEVADAS: Ya,
hal tersebut sangat lambat, benar?

459
00:24:35,270 --> 00:24:39,365
Akan membutuhkan waktu lebih lama untuk
menghitung nilai hash daripada mengakses

460
00:24:39,365 --> 00:24:40,740
kamusnya,
ketika Anda sesungguhnya

461
00:24:40,740 --> 00:24:44,847
mempunyai sebuah kamus yang ukurannya masuk akal
yang mungkin memiliki beberapa collision.

462
00:24:44,847 --> 00:24:46,930
Maksud saya Anda dapat memulainya dan
Anda punya sebuah linked list,

463
00:24:46,930 --> 00:24:50,090
Anda mampu menoleransi sedikit collision,
tidak masalahnya, benar?

464
00:24:50,090 --> 00:24:51,860
Jadi tidak
masuk akal

465
00:24:51,860 --> 00:24:57,420
untuk menggunakan fungsi
hash sekompleks ini,

466
00:24:57,420 --> 00:25:00,830
bahkan jika dia memenuhi
collision resistance-- yang

467
00:25:00,830 --> 00:25:04,070
beberapa di antaranya diduga untuk
melakukan-- untuk aplikasi-aplikasi

468
00:25:04,070 --> 00:25:04,617
yang sudah kita lihat.

469
00:25:04,617 --> 00:25:06,950
Tapi akan ada aplikasi-aplikasi lain
di mana collision resistance

470
00:25:06,950 --> 00:25:08,520
akan menjadi penting.

471
00:25:08,520 --> 00:25:10,110
Jadi itu adalah collision resistance.

472
00:25:10,110 --> 00:25:15,470
Lalu ada-- TCR adalah
Target Collision Resistance.

473
00:25:15,470 --> 00:25:18,300
Ini adalah bentuk yang lebih lemah--
jadi terkadang orang-orang (menganggap)

474
00:25:18,300 --> 00:25:24,190
CR adalah collision resistance yang kuat,
dan TCR collision resistance

475
00:25:24,190 --> 00:25:24,810
yang lemah.

476
00:25:24,810 --> 00:25:28,090
Kita akan menggunakan CR dan TCR di sini.

477
00:25:28,090 --> 00:25:35,460
Dan hal ini mengatakan hal tersebut
tidak mungkin, diberikan

478
00:25:35,460 --> 00:25:39,200
x-- jadi ada sebuah
x tertentu yang Anda

479
00:25:39,200 --> 00:25:41,590
ingin temukan collision
nya, alih-alih

480
00:25:41,590 --> 00:25:45,360
hanya mencari sebuah pasangan yang
hanya sekali menuju ke x dan x aksen.

481
00:25:45,360 --> 00:25:49,700
Dan pasangan apapun akan cukup untuk
merusak properti

482
00:25:49,700 --> 00:25:50,560
collision resistance tersebut.

483
00:25:50,560 --> 00:25:54,630
Tapi TCR mengatakan bahwa saya akan
memberikan Anda sebuah x tertentu.

484
00:25:54,630 --> 00:25:57,750
dan saya ingin Anda untuk
mencari sebuah x aksen yang

485
00:25:57,750 --> 00:26:01,050
hash-nya sama dengan
hash dari x, OK?

486
00:26:01,050 --> 00:26:02,065
Itu adalah TCR.

487
00:26:16,350 --> 00:26:18,082
OK itu adalah TCR bagi Anda.

488
00:26:18,082 --> 00:26:20,040
Dan supaya jelas,
saya rasa mungkin Anda semua

489
00:26:20,040 --> 00:26:23,420
mengerti hal ini, dengan jelas
kita menginginkan ini di sini

490
00:26:23,420 --> 00:26:26,340
karena kita memiliki sebuah
fungsi hash yang deterministik.

491
00:26:26,340 --> 00:26:29,430
Dan cukup jelas
untuk mengatakan bahwa jika Anda memiliki x,

492
00:26:29,430 --> 00:26:32,380
dan Anda memiliki x lagi, Anda
mendapatkan hash yang sama dari situ.

493
00:26:32,380 --> 00:26:33,740
Itu adalah sebuah kebutuhan, sungguh.

494
00:26:33,740 --> 00:26:36,670
Jadi kita ingin 2 nilai x yang berbeda
dan sekumpulan x aksen yang tidak

495
00:26:36,670 --> 00:26:38,590
sama yang pada akhirnya akan bertabrakan.

496
00:26:38,590 --> 00:26:40,890
Itu adalah arti sesungguhnya 
dari sebuah collision.

497
00:26:40,890 --> 00:26:44,200
Jadi Anda melihat perbedaan
antara CR dan TCR?

498
00:26:44,200 --> 00:26:44,700
Yup?

499
00:26:44,700 --> 00:26:45,812
Ya?

500
00:26:45,812 --> 00:26:49,144
AUDIENS: Apakah kita
mengasumsikan bahwa diketahui sebuah x

501
00:26:49,144 --> 00:26:51,105
itu sangat mudah untuk
mendapatkan h dari x kembali?

502
00:26:51,105 --> 00:26:52,480
SRINIVAS DEVADAS:
Jadi pertanyaannya

503
00:26:52,480 --> 00:26:57,150
adalah, diketahui suatu x, itu adalah komputasi
dengan waktu polinomial untuk mendapatkan h dari x.

504
00:26:57,150 --> 00:26:58,230
Benar.

505
00:26:58,230 --> 00:27:02,480
Komputasi publik dengan waktu polinomial
diketahui suatu x untuk mendapatkan h dari x.

506
00:27:02,480 --> 00:27:08,840
Jadi berjalan ke arah sini mudah.

507
00:27:08,840 --> 00:27:15,170
Berjalan ke arah sini-- saya lari
keluar dari ruangan-- sulit.

508
00:27:15,170 --> 00:27:16,954
OK?

509
00:27:16,954 --> 00:27:20,160
AUDIENS: Jadi apakah itu berarti bahwa
TCR pada dasarnya sama dengan 1?

510
00:27:20,160 --> 00:27:22,230
SRINIVAS DEVADAS: Tidak,
tidak, tidak, sama sekali tidak.

511
00:27:22,230 --> 00:27:25,890
TCR bilang tidak apa-apa.

512
00:27:25,890 --> 00:27:27,620
Anda dapat menghitung hal ini.

513
00:27:27,620 --> 00:27:29,030
Anda bisa mendapatkan x.

514
00:27:29,030 --> 00:27:30,720
Dan Anda bisa mendapatkan h dari x.

515
00:27:30,720 --> 00:27:33,125
Jadi diberikan x, Anda tahu
bahwa Anda bisa mendapatkan h dari x.

516
00:27:33,125 --> 00:27:35,000
Saya sebenarnya tidak menaruh
hal itu di dalam definisi.

517
00:27:35,000 --> 00:27:36,800
Dan mungkin saya seharusnya melakukan hal itu.

518
00:27:36,800 --> 00:27:38,860
Jadi diberikan x Anda bisa
selalu dapatkan h dari x.

519
00:27:38,860 --> 00:27:40,080
Ingat hal itu.

520
00:27:40,080 --> 00:27:41,640
Sangat mudah untuk mendapatkan h dari x.

521
00:27:41,640 --> 00:27:44,350
Jadi kapan pun saya mengatakan diberikan
x, Anda selalu dapat menambahkannya,

522
00:27:44,350 --> 00:27:46,400
mengatakan diberikan x dan h dari x.

523
00:27:46,400 --> 00:27:48,690
Jadi saya diberikan x.

524
00:27:48,690 --> 00:27:49,960
Saya diberikan h dari x.

525
00:27:49,960 --> 00:27:53,600
Jelas bahwa saya harus 
memetakan-- saya harus menemukan

526
00:27:53,600 --> 00:27:58,080
sebuah x aksen sehingga h dari
x aksen sama dengan h dari x, OK?

527
00:27:58,080 --> 00:28:04,490
Sekarang Anda mempunyai situasi-situasi
di mana untuk-- itu

528
00:28:04,490 --> 00:28:07,920
mungkin kasus di mana 
untuk nilai-nilai x tertentu Anda

529
00:28:07,920 --> 00:28:08,900
sesungguhnya bisa melakukan hal ini.

530
00:28:08,900 --> 00:28:10,363
Dan itu cukup untuk merusak TCR.

531
00:28:13,270 --> 00:28:15,640
Jadi Anda harus mempunyai
properti yang kuat ini

532
00:28:15,640 --> 00:28:22,520
yang Anda sangat tidak inginkan untuk
menemukan collisions untuk beberapa--

533
00:28:22,520 --> 00:28:26,470
bahkan jika ada sebuah pecahan
konstan dari nilai-nilai x yang

534
00:28:26,470 --> 00:28:29,210
merusak properti TCR, Anda
tidak menyukai fungsi hash Anda,

535
00:28:29,210 --> 00:28:29,710
OK?

536
00:28:29,710 --> 00:28:31,850
Karena Anda mungkin pada akhirnya akan
memilihnya itu dan lanjut

537
00:28:31,850 --> 00:28:35,490
membangun aplikasi-aplikasi keamanan
menggunakan properti-properti tersebut.

538
00:28:35,490 --> 00:28:37,990
Saya ingin membahas sedikit
mengenai hubungan

539
00:28:37,990 --> 00:28:41,240
antara OW, CR, dan TCR.

540
00:28:41,240 --> 00:28:42,700
Jadi saya akan
kembali ke situ.

541
00:28:42,700 --> 00:28:45,290
Dan kita akan berbicara
mengenai fungsi-fungsi hash yang

542
00:28:45,290 --> 00:28:48,076
memenuhi satu properti tetapi
tidak memenuhi yang lainnya.

543
00:28:48,076 --> 00:28:49,700
Dan saya pikir
pertanyaan Anda mungkin

544
00:28:49,700 --> 00:28:52,150
akan terjawab lebih baik, OK?

545
00:28:52,150 --> 00:28:53,460
Terima kasih atas pertanyaannya.

546
00:28:53,460 --> 00:28:56,160
Jadi hal-hal itu adalah yang utama.

547
00:28:56,160 --> 00:28:59,260
Dan dengan cepat, jika Anda
ingin menghabiskan banyak waktu

548
00:28:59,260 --> 00:29:02,972
dalam hal ini-- tetapi saya
ingin mengatakan--

549
00:29:02,972 --> 00:29:05,320
Saya rasa saya akan meninggalkan
properti-properti ini di atas sini

550
00:29:05,320 --> 00:29:06,590
untuk sekarang.

551
00:29:06,590 --> 00:29:10,350
Karena penting bagi Anda
untuk melihat definisi-definisi ini

552
00:29:10,350 --> 00:29:13,580
selagi kita melihat
aplikasi-aplikasi di mana kita

553
00:29:13,580 --> 00:29:17,090
membutuhkan properti-properti ini, atau
sebagian dari properti-properti ini.

554
00:29:17,090 --> 00:29:19,580
Tapi kita memiliki
keacakan semu.

555
00:29:19,580 --> 00:29:22,910
Dan ini hanya sebuah
fungsi dari fakta

556
00:29:22,910 --> 00:29:31,100
bahwa-- jadi ini adalah PRF-- kita tahu
kita tidak bisa membangun sebuah pembangkit nilai acak.

557
00:29:31,100 --> 00:29:35,300
Jadi kita akan harus melakukan
sesuatu yang acak secara semu (pseudo-random).

558
00:29:35,300 --> 00:29:37,840
Dan pada dasarnya apa
yang kita bahas di sini

559
00:29:37,840 --> 00:29:45,870
adalah perilaku yang
tidak dapat dipisahkan dari keacakan.

560
00:29:50,990 --> 00:29:56,140
Jadi kita akan harus menggunakan
ke-non-linear-an, hal-hal yang

561
00:29:56,140 --> 00:29:58,730
disebut sebagai non-linear
feedback shift registers,

562
00:29:58,730 --> 00:30:00,370
untuk menciptakan fungsi-fungsi
acak yang semu (pseudo-random).

563
00:30:00,370 --> 00:30:03,710
Ada banyak cara agar kita dapat
menciptakan fungsi-fungsi semu acak.

564
00:30:03,710 --> 00:30:05,310
Kita tidak akan membahas hal itu terlalu dalam.

565
00:30:05,310 --> 00:30:07,680
Tapi jelas itu adalah
hal yang kita inginkan.

566
00:30:07,680 --> 00:30:14,420
Lalu yang terakhir
sedikit rumit.

567
00:30:14,420 --> 00:30:18,830
Dan kita akan mempunyai sebuah aplikasi yang
membutuhkan cara ini pada akhirnya.

568
00:30:18,830 --> 00:30:29,240
Tapi ini tidak memungkinkan
diketahui h dari x

569
00:30:29,240 --> 00:30:42,010
untuk menghasilkan h dari x aksen, di mana
x dan x aksen adalah-- ini menjadi

570
00:30:42,010 --> 00:30:50,150
sedikit kabur disini-- 
berhubungan dalam beberapa segi, benar?

571
00:30:50,150 --> 00:30:53,630
Jadi sebuah contoh
yang konkret dari hal ini adalah,

572
00:30:53,630 --> 00:30:59,770
mari katakan x
aksen adalah x tambah 1.

573
00:30:59,770 --> 00:31:02,630
Jadi ini adalah sebuah contoh
yang masuk akal dari hal ini.

574
00:31:02,630 --> 00:31:09,930
Jadi apa yang dimaksud dengan hal ini adalah
Anda hanya diberikan h dari x.

575
00:31:09,930 --> 00:31:12,680
Ini sesungghunya belum mengimplikasikan
apapun mengenai ke-satu-arah-an.

576
00:31:12,680 --> 00:31:14,670
Tapi Anda dapat
mengasumsikan, contohnya,

577
00:31:14,670 --> 00:31:18,510
bahwa jika ini adalah sebuah
fungsi hash yang satu arah,

578
00:31:18,510 --> 00:31:23,581
akan memungkinkan untuk
mendapatkan x dari h(x), benar?

579
00:31:26,300 --> 00:31:28,070
Dan mari kita simpan hal itu.

580
00:31:28,070 --> 00:31:29,470
Simpan pemikiran itu, baik?

581
00:31:29,470 --> 00:31:31,290
Kita akan kembali ke hal tersebut.

582
00:31:31,290 --> 00:31:36,710
Jadi jika saya hanya diberikan hash
melalui sebuah perhitungan.

583
00:31:36,710 --> 00:31:40,300
akan memungkinkan bagi saya
untuk menciptakan hash lain, h

584
00:31:40,300 --> 00:31:45,330
dari x aksen, sehingga
ada suatu hubungan

585
00:31:45,330 --> 00:31:51,010
yang dapat saya buktikan atau berikan argumen
antara string-string yang

586
00:31:51,010 --> 00:31:54,390
menciptakan hash-hash tersebut,
yaitu x dan x aksen, OK?

587
00:31:54,390 --> 00:31:57,330
Itulah apa
yang dimaksud malleability, benar?

588
00:31:57,330 --> 00:32:03,440
Sekarang Anda mungkin akan lompat pada kesimpulan dan
mengatakan ini adalah x, ini adalah y,

589
00:32:03,440 --> 00:32:07,700
ini adalah h(x),
dan ini adalah h(y).

590
00:32:07,700 --> 00:32:09,620
Hal-hal ini terlihat seperti sepenuhnya acak.

591
00:32:09,620 --> 00:32:12,890
Dan Anda mungkin akan lompat pada kesimpulan-- saya
sedang bercanda disini-- saya

592
00:32:12,890 --> 00:32:17,767
mengatakan bahwa y adalah saudara ipar dari
teman sekamar dari sepupu ketiga dari x.

593
00:32:17,767 --> 00:32:18,600
atau sesuatu, benar?

594
00:32:18,600 --> 00:32:20,600
Maksud saya karang
saja sesuatu, benar?

595
00:32:20,600 --> 00:32:26,470
Jadi jelas harus ada
sebuah hubungan kuat dan tepat

596
00:32:26,470 --> 00:32:27,780
antara x dan y.

597
00:32:27,780 --> 00:32:32,180
Jika faktanya Anda dapat
melakukan ini dan mendapatkan y

598
00:32:32,180 --> 00:32:36,160
sama dengan x tambah 1, itu
akan menjadi masalah, benar?

599
00:32:36,160 --> 00:32:38,840
Tapi jika Anda--
lalu Anda dapat

600
00:32:38,840 --> 00:32:42,280
melakukan hal ini secara agak konsisten
untuk nilai-nilai x dan y yang berbeda, itu

601
00:32:42,280 --> 00:32:44,980
pasti akan menjadi
sebuah masalah, benar?

602
00:32:44,980 --> 00:32:48,440
Tapi hal yang sesungguhnya Anda
minta-- dan khususnya

603
00:32:48,440 --> 00:32:50,710
ketika Anda menginginkan
non-malleability-- seperti

604
00:32:50,710 --> 00:32:55,000
di mana Anda mempunyai
pelelangan, contohnya, di mana

605
00:32:55,000 --> 00:32:58,350
Anda berhati-hati dalam
memastikan bahwa Anda tidak ingin

606
00:32:58,350 --> 00:33:01,320
menunjukkan tawaran Anda.

607
00:33:01,320 --> 00:33:04,700
Jadi apa yang mungkin Anda
lakukan adalah menunjukkan h(x).

608
00:33:04,700 --> 00:33:08,960
Anda tidak ingin seseorang
melihat h(x) Anda

609
00:33:08,960 --> 00:33:10,420
dan mengetahui bagaimana
mereka bisa mengalahkan

610
00:33:10,420 --> 00:33:13,540
tawaran Anda hanya dengan melebihkan sedikit saja.

611
00:33:13,540 --> 00:33:17,140
Atau pada kasus pelelangan Vickrey,
di mana penawar tertinggi kedua

612
00:33:17,140 --> 00:33:20,031
menang, sekarang hanya sedikit
di bawah Anda, benar?

613
00:33:20,031 --> 00:33:21,530
Jadi hal itu adalah jenis
hal yang Anda

614
00:33:21,530 --> 00:33:25,110
ingin pikirkan ketika
berhubungan dengan non-malleability,

615
00:33:25,110 --> 00:33:28,880
atau malleability, di mana Anda
menginginkan sebuah hubungan yang kuat

616
00:33:28,880 --> 00:33:32,300
antara dua string
yang berhubungan

617
00:33:32,300 --> 00:33:35,510
dengan suatu urutan tertentu,
seperti x sama dengan-- x aksen

618
00:33:35,510 --> 00:33:38,950
sama dengan x plus 1, atau hanya
x aksen sama dengan 2 kali x.

619
00:33:38,950 --> 00:33:43,040
Dan Anda tidak mau
agar bisa-- Anda

620
00:33:43,040 --> 00:33:45,350
tidak menginginkan musuh
untuk dapat menemukan

621
00:33:45,350 --> 00:33:47,670
string-string baru ini.

622
00:33:47,670 --> 00:33:51,440
Karena itu akan menjadi
sistemnya, OK?

623
00:33:51,440 --> 00:33:55,580
Jadi ada pertanyaan
tentang properti-properti?

624
00:33:55,580 --> 00:33:57,620
Apakah semua jelas tentang
properti-properti ini?

625
00:33:57,620 --> 00:33:59,840
Baiklah, karena saya
akan mulai bertanya kepada Anda

626
00:33:59,840 --> 00:34:03,010
bagaimana cara menggunakan mereka untuk
aplikasi-aplikasi tertentu,

627
00:34:03,010 --> 00:34:09,170
atau properti-properti apa yang dibutuhkan
untuk aplikasi-aplikasi tertentu, OK?

628
00:34:09,170 --> 00:34:11,150
Satu hal lagi
sebelum kita ke sana.

629
00:34:11,150 --> 00:34:16,960
Saya menjanjikan sebuah
analisis yang sedikit lebih rinci

630
00:34:16,960 --> 00:34:20,170
tentang hubungan
antara properti-properti ini.

631
00:34:20,170 --> 00:34:20,974
Jadi mari kita lakukan hal tersebut.

632
00:34:24,810 --> 00:34:27,830
Sekarang jika Anda
melihatnya, memperhatikannya,

633
00:34:27,830 --> 00:34:34,888
dan Anda perhatikan pada
collision resistance dan TCR,

634
00:34:34,888 --> 00:34:36,429
hal apa yang dapat saya katakan
tentang relasi

635
00:34:36,429 --> 00:34:40,820
antara CR dan TCR?

636
00:34:40,820 --> 00:34:45,953
Jika h adalah CR, dia akan
menjadi TCR, benar?

637
00:34:45,953 --> 00:34:46,744
Dia pasti menjadi TCR.

638
00:34:46,744 --> 00:34:48,735
Ini adalah kebutuhan
yang lebih ketat.

639
00:34:54,659 --> 00:34:55,415
Tapi tidak kebalikannya.

640
00:34:57,940 --> 00:35:04,230
Dan Anda sebenarnya dapat
memberikan sebuah contoh konkret

641
00:35:04,230 --> 00:35:07,077
tentang fungsi hash tertentu
yang merupakan TCR.

642
00:35:07,077 --> 00:35:08,160
Saya tidak akan membahas sampai ke sana.

643
00:35:08,160 --> 00:35:09,659
Itu sebenarnya
sedikit lebih terlibat

644
00:35:09,659 --> 00:35:12,780
daripada yang mungkin Anda pikirkan,
di mana sebuah fungsi hash TCR

645
00:35:12,780 --> 00:35:14,430
bukan merupakan collision resistant.

646
00:35:14,430 --> 00:35:17,180
Tapi Anda dapat melihat bahwa
contoh-contoh seperti ini

647
00:35:17,180 --> 00:35:20,340
seharusnya ada, hanya karena saya
memiliki properti yang lebih ketat

648
00:35:20,340 --> 00:35:22,280
yang berkaitan dengan
collision resistance

649
00:35:22,280 --> 00:35:24,680
daripada TCR, benar?

650
00:35:24,680 --> 00:35:27,170
Jadi jika Anda tertarik dengan
contoh tertentu itu,

651
00:35:27,170 --> 00:35:29,780
walaupun tidak wajib,
hubungi saya

652
00:35:29,780 --> 00:35:32,545
dan saya akan mengarahkan Anda ke,
penjelasan yang berisi contoh

653
00:35:32,545 --> 00:35:34,180
dan panjangnya tiga halaman.

654
00:35:34,180 --> 00:35:35,930
Jadi saya tidak terlalu
menjelaskan lebih dalam.

655
00:35:35,930 --> 00:35:40,170
Tapi yang saya ingin lakukan adalah bicara
mengenai ke-satu-arah-an dan collision

656
00:35:40,170 --> 00:35:40,820
resistance.

657
00:35:40,820 --> 00:35:43,069
Karena menurut saya itu
jauh lebih menarik,

658
00:35:43,069 --> 00:35:43,720
OK?

659
00:35:43,720 --> 00:35:59,060
Jadi jika h itu satu arah--
apakah ada yang ingin menebak

660
00:35:59,060 --> 00:36:03,370
apa tanda tanya
yang ada di tengah itu?

661
00:36:03,370 --> 00:36:07,950
Bisakah saya membuat pernyataan kuat
mengenai collision resistance

662
00:36:07,950 --> 00:36:10,430
dari sebuah fungsi hash,
jika saya digaransikan

663
00:36:10,430 --> 00:36:14,010
bahwa fungsi hash yang saya punya
adalah fungsi hash satu arah,

664
00:36:14,010 --> 00:36:14,730
atau sebaliknya?

665
00:36:20,960 --> 00:36:23,080
Cara lain untuk
mengatakannya adalah, bisakah Anda

666
00:36:23,080 --> 00:36:28,970
memberikan contoh kepada saya,
untuk memulai saja,

667
00:36:28,970 --> 00:36:35,096
sebuah fungsi hash yang satu
arah tapi tidak TCR, tidak

668
00:36:35,096 --> 00:36:36,220
target collision resistant?

669
00:36:40,520 --> 00:36:43,540
Jadi saya akan mencoba
mengekstrak hal ini dari Anda.

670
00:36:43,540 --> 00:36:46,870
Hal ini cukup rumit.

671
00:36:46,870 --> 00:36:48,990
Tapi bagaimana Anda 
memikirkan hal ini

672
00:36:48,990 --> 00:36:59,260
adalah, katakanlah h(x)
adalah OW dan TCR, OK?

673
00:36:59,260 --> 00:37:02,660
Jadi saya punya banyak masukan.

674
00:37:02,660 --> 00:37:03,660
Dan ini adalah keluarannya.

675
00:37:03,660 --> 00:37:06,160
Dan saya mendapatkan keluaran d-bit.

676
00:37:06,160 --> 00:37:12,010
Dan saya mempunyai x1, x2, hingga xn, OK?

677
00:37:12,010 --> 00:37:16,620
Sekarang saya telah diberikan h ini--
Saya telah diberikan h ini yang

678
00:37:16,620 --> 00:37:18,240
merupakan satu arah dan TCR.

679
00:37:18,240 --> 00:37:20,960
Hal tersebut memenuhi properti-properti itu
yang Anda miliki di atas sana.

680
00:37:20,960 --> 00:37:24,590
Dalam kasus satu arah, saya memberikan
Anda sebuah string d-bit acak.

681
00:37:24,590 --> 00:37:28,770
Anda tidak bisa mundur dan
menemukan sekumpulan xi yang

682
00:37:28,770 --> 00:37:34,150
menghasilkan string d-bit 
persis seperti itu, OK?

683
00:37:34,150 --> 00:37:36,530
Jadi akan sulit
untuk sampai kesini.

684
00:37:36,530 --> 00:37:40,380
Tapi sekarang Anda diperbolehkan
untuk memberi saya sebuah contoh.

685
00:37:40,380 --> 00:37:45,390
Jadi ini adalah beberapa fungsi
hash yang bisa Anda buat,

686
00:37:45,390 --> 00:37:48,300
yang mungkin menggunakan h juga.

687
00:37:48,300 --> 00:37:51,780
Dan h cukup bagus karena
ia memiliki properti satu arah ini.

688
00:37:51,780 --> 00:37:55,030
Jadi katakanlah bahwa kita ingin
menemukan sesuatu di mana

689
00:37:55,030 --> 00:37:59,080
satu arah tidak berarti TCR.

690
00:37:59,080 --> 00:38:03,490
Jadi saya ingin membuat sebuah
fungsi hash h aksen sehingga

691
00:38:03,490 --> 00:38:09,550
h aksen tersebut satu arah,
tapi bukan TCR, OK?

692
00:38:09,550 --> 00:38:13,610
Cara yang Anda ingin pikirkan
tentang hal ini adalah Anda tambahkan ke h.

693
00:38:13,610 --> 00:38:16,790
Dan Anda ingin menambahkan sesuatu
terhadap h agar tetap sulit--

694
00:38:16,790 --> 00:38:20,347
jika Anda menambahkan h tetap sulit
untuk pergi dari sini ke sana.

695
00:38:20,347 --> 00:38:21,680
Karena Anda harus pergi lebih dalam.

696
00:38:21,680 --> 00:38:23,760
Jika Anda menambahkan ke, sebagai
contoh, masukan-masukan dari h.

697
00:38:23,760 --> 00:38:26,170
Atau Anda bisa menambahkan ke
keluaran-keluaran dari h juga,

698
00:38:26,170 --> 00:38:27,730
atau keluaran-keluaran dari h saat ini.

699
00:38:27,730 --> 00:38:34,670
Tapi pada dasarnya Anda bisa pergi lebih dalam,
atau harus pergi lebih dalam untuk

700
00:38:34,670 --> 00:38:39,580
menemukan pemutusan
ke-satu-arah-an, untuk

701
00:38:39,580 --> 00:38:43,820
menemukan sebuah x, apapun yang Anda miliki,
yang menghasilkan string d-bit

702
00:38:43,820 --> 00:38:44,910
yang Anda miliki, benar?

703
00:38:44,910 --> 00:38:49,690
Jadi apa cara sederhana untuk
membuat sebuah h aksen agar

704
00:38:49,690 --> 00:38:53,700
menjadi cukup mudah untuk
menemukan collision yang terarah,

705
00:38:53,700 --> 00:38:56,150
tidak harus berupa collision,
cukup mudah untuk menemukan

706
00:38:56,150 --> 00:38:58,740
collision terarah,
tanpa merusak

707
00:38:58,740 --> 00:39:00,180
properti ke-satu-arah-an dari h?

708
00:39:03,785 --> 00:39:05,264
Ya?

709
00:39:05,264 --> 00:39:11,673
AUDIENS: Jadi jika Anda mempunyai
x sub i, jika i ganjil maka

710
00:39:11,673 --> 00:39:14,631
kembalikan h(x) dari i.

711
00:39:14,631 --> 00:39:16,603
Agar ia berkurang 1.

712
00:39:16,603 --> 00:39:18,552
Jadi keluarkan kelompok yang genap.

713
00:39:18,552 --> 00:39:19,510
SRINIVAS DEVADAS: Tentu saja.

714
00:39:19,510 --> 00:39:21,004
Ya.

715
00:39:21,004 --> 00:39:24,241
AUDIENS: Diberikan
x apa saja x dari i, Anda

716
00:39:24,241 --> 00:39:27,478
biasanya dapat menemukan x lain dari
i yang memiliki keluaran yang sama?

717
00:39:27,478 --> 00:39:28,980
Anda bisa mundur.

718
00:39:28,980 --> 00:39:29,700
SRINIVAS DEVADAS: Anda
tidak bisa mundur.

719
00:39:29,700 --> 00:39:30,500
Ya, itu bagus.

720
00:39:30,500 --> 00:39:31,450
Itu bagus.

721
00:39:31,450 --> 00:39:34,114
Saya akan melakukan sesuatu yang
hampir sama dengan yang Anda katakan.

722
00:39:34,114 --> 00:39:35,655
Tetapi saya akan
menggambarkannya.

723
00:39:38,270 --> 00:39:42,705
Dan yang dapat Anda lakukan, Anda dapat
melakukan sebuah pembatas, seperti ganjil dan genap

724
00:39:42,705 --> 00:39:43,705
yang baru saja dijelaskan.

725
00:39:47,520 --> 00:39:51,440
Dan yang akan saya lakukan adalah menambah
gerbang [? XNOR ?]

726
00:39:51,440 --> 00:39:55,240
kecil, yang merupakan gerbang
parity, terhadap salah satu masukannya.

727
00:39:55,240 --> 00:39:56,830
Jadi Anda mempunyai a dan b di sini.

728
00:39:56,830 --> 00:40:01,010
Jadi saya telah mengambil x1, dan
saya mempunyai a dan b di sini.

729
00:40:01,010 --> 00:40:04,560
Jadi saya telah menambahkan-- saya dapat
menambahkan masukan sebanyak

730
00:40:04,560 --> 00:40:06,190
yang saya inginkan untuk fungsi ini.

731
00:40:06,190 --> 00:40:08,830
Oh omong-omong saya
sebaiknya mengatakan, h(x)

732
00:40:08,830 --> 00:40:11,290
berfungsi pada string-string acak.

733
00:40:11,290 --> 00:40:13,630
Dan tentunya saya
memasukkan suatu angka

734
00:40:13,630 --> 00:40:16,774
di sini yang berhubungan dengan
n, yang merupakan angka yang tidak berubah.

735
00:40:16,774 --> 00:40:19,190
Jadi Anda mungkin bertanya, apa
yang terjadi di sini yang berkaitan

736
00:40:19,190 --> 00:40:20,610
terhadap string-string acak?

737
00:40:20,610 --> 00:40:22,570
Dan ada dua jawaban.

738
00:40:22,570 --> 00:40:25,000
Jawaban pertama adalah,
yah, abaikan keacakan.

739
00:40:25,000 --> 00:40:27,350
Dan asumsikan bahwa Anda
hanya mempunyai string-string n-bit.

740
00:40:27,350 --> 00:40:29,370
Dan n ini merupakan angka
yang sangat besar, benar?

741
00:40:29,370 --> 00:40:31,500
Dan hal itu mungkin tidak
terlalu memuaskan.

742
00:40:31,500 --> 00:40:34,220
Jawaban lainnya adalah,
yang lebih praktis,

743
00:40:34,220 --> 00:40:35,850
yang merupakan hal yang
digunakan dalam praktik,

744
00:40:35,850 --> 00:40:38,140
adalah biasanya
apa yang terjadi adalah,

745
00:40:38,140 --> 00:40:41,000
Anda memiliki
implementasi tertentu

746
00:40:41,000 --> 00:40:43,180
dari fungsi-fungsi hash yang
jelas perlu memiliki

747
00:40:43,180 --> 00:40:46,440
masukan-masukan tetap, n, sebagai contoh.

748
00:40:46,440 --> 00:40:48,110
Dan n biasanya 512.

749
00:40:48,110 --> 00:40:49,680
Itu biasanya adalah ukuran bloknya.

750
00:40:49,680 --> 00:40:52,940
Dan Anda potong inputnya sampai
menjadi 5 blok 12-bit.

751
00:40:52,940 --> 00:40:54,770
Dan biasanya apa
yang Anda lakukan adalah, Anda

752
00:40:54,770 --> 00:40:57,800
pilih 5 blok 12 bit pertama,
hitung fungsi hash-nya.

753
00:40:57,800 --> 00:41:02,280
Dan kemudian Anda dapat melakukannya
untuk blok-blok sisanya.

754
00:41:02,280 --> 00:41:04,530
Dan kemudian Anda dapat hash
mereka semua bersamaan, benar?

755
00:41:04,530 --> 00:41:06,872
Jadi biasanya ada
pemanggilan-pemanggilan lebih.

756
00:41:06,872 --> 00:41:08,330
Saya tidak terlalu ingin
membahasnya lebih dalam.

757
00:41:08,330 --> 00:41:11,370
Tapi biasanya ada
pemanggilan-pemanggilan lebih dari h

758
00:41:11,370 --> 00:41:15,600
ketika inputnya akan menjadi 2 kali
n, atau 3 kali n, baik?

759
00:41:15,600 --> 00:41:17,410
Jadi kita tidak perlu
melihat ke sana

760
00:41:17,410 --> 00:41:18,960
untuk tujuan dari
perkuliahan ini.

761
00:41:18,960 --> 00:41:20,270
Tapi ingatlah hal itu.

762
00:41:20,270 --> 00:41:23,750
Jadi kita masih tetap dengan
kebutuhan string acak.

763
00:41:23,750 --> 00:41:26,410
Jadi setelah mengatakan itu,
lihatlah gambar ini.

764
00:41:26,410 --> 00:41:30,190
Dan lihat apa yang
diimplikasikan oleh gambar ini.

765
00:41:30,190 --> 00:41:33,340
Saya punya sebuah h aksen yang
sudah saya bangun, benar?

766
00:41:33,340 --> 00:41:36,720
Sekarang jika saya lihat h
aksen, dan saya berikan Anda

767
00:41:36,720 --> 00:41:40,270
sebuah keluaran untuk h aksen--
jadi h aksen sekarang memiliki,

768
00:41:40,270 --> 00:41:45,640
itu sebuah fungsi dari a dan b, dan
x2 hingga xn, benar?

769
00:41:45,640 --> 00:41:47,850
Jadi dia memiliki masukan tambahan.

770
00:41:47,850 --> 00:41:50,630
Jika saya melihat h aksen, dan saya melihat
pada keluaran dari h aksen yang

771
00:41:50,630 --> 00:41:56,280
diberikan kepada saya, dan saya
harus menemukan sesuatu yang

772
00:41:56,280 --> 00:42:00,280
menghasilkan hal itu, ini cukup
jelas bahwa saya perlu mencari tahu

773
00:42:00,280 --> 00:42:03,400
apa nilai-nilai ini,
OK?

774
00:42:03,400 --> 00:42:06,930
Dan saya harus tahu apa
parity dari a dan b.

775
00:42:06,930 --> 00:42:09,293
Dan mungkin saya tidak perlu
tahu persis apa itu a dan b,

776
00:42:09,293 --> 00:42:11,626
tapi saya benar-benar perlu tahu
apa parity dari a dan b,

777
00:42:11,626 --> 00:42:13,230
karena itu adalah x1.

778
00:42:13,230 --> 00:42:15,490
Dan satu arah yang saya
rusak akan membutuhkan

779
00:42:15,490 --> 00:42:17,670
saya untuk memberitahu Anda
apa nilai dari x1,

780
00:42:17,670 --> 00:42:20,070
dan nilai dari x2,
dan selanjutnya.

781
00:42:20,070 --> 00:42:23,640
Jadi cukup jelas bahwa
h aksen itu satu arah, benar?

782
00:42:23,640 --> 00:42:25,520
Semuanya mengerti?

783
00:42:25,520 --> 00:42:28,870
h aksen adalah satu arah.

784
00:42:28,870 --> 00:42:30,160
Tapi tahukah Anda?

785
00:42:30,160 --> 00:42:33,860
Saya punya collision
terarah yang berlimpah, benar?

786
00:42:33,860 --> 00:42:37,360
Yang harus saya lakukan adalah membalik-- Saya
memiliki a sama dengan 1 dan b sama dengan 1.

787
00:42:37,360 --> 00:42:39,770
Dan saya memiliki yang a sama dengan
0 dan b sama dengan 0.

788
00:42:39,770 --> 00:42:42,350
Mereka akan memberi
saya hash yang sama, benar?

789
00:42:42,350 --> 00:42:45,690
Jadi contoh sepele,
tapi itu sampai

790
00:42:45,690 --> 00:42:50,070
pada inti dari perbedaan
antara collision resistance

791
00:42:50,070 --> 00:42:52,290
dan ke-satu-arah-an,
target collision resistance

792
00:42:52,290 --> 00:42:54,210
and ke-satu-arah-an, OK?

793
00:42:54,210 --> 00:43:03,710
Jadi ini satu-arah tapi bukan TCR,
hanya karena a sama dengan 0, b

794
00:43:03,710 --> 00:43:06,500
sama dengan 0 untuk
nilai-nilai x acak menghasilkan

795
00:43:06,500 --> 00:43:11,200
hal yang sama ketika a sama dengan
1 dan b sama dengan 1, benar?

796
00:43:11,200 --> 00:43:13,940
Jadi itulah collision.

797
00:43:13,940 --> 00:43:15,690
Jadi memang dibuat-buat.

798
00:43:15,690 --> 00:43:19,350
Tapi itu contohnya.

799
00:43:19,350 --> 00:43:21,150
Contoh
dapat dibuat-buat.

800
00:43:21,150 --> 00:43:23,510
Tidak apa-apa.

801
00:43:23,510 --> 00:43:24,710
Baiklah.

802
00:43:24,710 --> 00:43:28,470
Jadi tadi adalah apa
yang terjadi dengan hal itu.

803
00:43:28,470 --> 00:43:32,400
Mari lihat satu
hal lagi yang menarik

804
00:43:32,400 --> 00:43:36,150
yang berhubungan dengan
cara lain, OK?

805
00:43:36,150 --> 00:43:46,030
Jadi hal yang ingin saya tunujukkan adalah
sebuah TCR tidak berarti ke-satu-arah-an.

806
00:43:59,040 --> 00:44:03,122
OK, jadi sekarang saya ingin memberikan
contoh dimana terlihat jelas

807
00:44:03,122 --> 00:44:05,580
bahwa saya mempunyai ketahanan terhadap
collision terarah, karena saya hanya bisa

808
00:44:05,580 --> 00:44:06,370
mengasumsikan hal tersebut.

809
00:44:06,370 --> 00:44:08,310
Dan kita akan 
menggunakan strategi yang sama.

810
00:44:08,310 --> 00:44:10,550
Saya hanya akan mengasumsikan
bahwa saya memiliki sebuah h yang

811
00:44:10,550 --> 00:44:12,240
target collision resistant.

812
00:44:12,240 --> 00:44:16,250
Dan saya akan mencoba dan membuat
sebuah h aksen yang tidak satu arah.

813
00:44:16,250 --> 00:44:21,080
Jadi saya akan berasumsi bahwa
faktanya h adalah TCR dan OW.

814
00:44:21,080 --> 00:44:24,420
Dan saya akan mengambil
salah satu propertinya.

815
00:44:24,420 --> 00:44:26,060
Dan jika saya ambil salah
satu propertinya

816
00:44:26,060 --> 00:44:28,350
Saya mendapatkan sebuah contoh, benar?

817
00:44:28,350 --> 00:44:34,320
Jadi pikirkan bagaimana
Anda dapat melakukan hal ini.

818
00:44:34,320 --> 00:44:38,355
Anda memiliki h seperti sebelumnya.

819
00:44:41,920 --> 00:44:46,330
Dan saya ingin menambahkan
beberapa hal di sekitarnya

820
00:44:46,330 --> 00:44:52,820
agar dia dapat ditemukan
dengan mudah-- untuk sebagian besar,

821
00:44:52,820 --> 00:44:55,610
untuk sebagian hash
yang tetap

822
00:44:55,610 --> 00:44:58,430
yang telah saya berikan ke diri saya sendiri,
bukan hanya hash biasa saja.

823
00:44:58,430 --> 00:45:01,000
Karena Anda selalu bisa
menyatakan bahwa ke-satu-arah-an

824
00:45:01,000 --> 00:45:06,360
rusak dengan mengatakan saya memiliki
x, saya menghitung h(x), sekarang

825
00:45:06,360 --> 00:45:09,780
saya mengetahui apa-- diberikannya h(x)
saya tahu apa nilai x.

826
00:45:09,780 --> 00:45:11,970
Maksud saya Anda tidak dapat melakukan hal itu, benar?

827
00:45:11,970 --> 00:45:14,360
Jadi itu tidak merusak
sifat ke-satu-arah-an.

828
00:45:14,360 --> 00:45:16,420
Ketika Anda memiliki
sebuah h(x) dan ini

829
00:45:16,420 --> 00:45:18,250
adalah pertama kali
Anda melihatnya,

830
00:45:18,250 --> 00:45:20,660
Anda mencoba untuk mencari
apa itu x, benar?

831
00:45:20,660 --> 00:45:23,370
Jadi bagaimana Anda-- bagaimana
Anda akan menyiapkannya

832
00:45:23,370 --> 00:45:28,230
agar Anda merusak
ke-satu-arah-an dari h

833
00:45:28,230 --> 00:45:31,310
tanpa harus merusak
target collision

834
00:45:31,310 --> 00:45:37,430
resistance dari keseluruhan fungsi
hash yang Anda buat?

835
00:45:37,430 --> 00:45:41,339
Dan Anda harus melakukan sesuatu
dengan keluarannya, OK?

836
00:45:41,339 --> 00:45:42,380
Anda harus melakukan sesuatu.

837
00:45:42,380 --> 00:45:43,671
Hal ini sedikit lebih sulit.

838
00:45:43,671 --> 00:45:45,734
Itu tidak semudah
contoh ini.

839
00:45:45,734 --> 00:45:46,900
Itu sedikit lebih terlibat.

840
00:45:46,900 --> 00:45:47,920
Tapi ada ide?

841
00:45:51,240 --> 00:45:52,761
Ya, silakan.

842
00:45:52,761 --> 00:45:55,707
AUDIENS: Jadi x kurang
dari b kembalikan x.

843
00:45:55,707 --> 00:45:57,964
Jika x lebih besar dari
b, kembalikan [TIDAK TERDENGAR]

844
00:45:57,964 --> 00:45:59,130
SRINIVAS DEVADAS: Indah sekali.

845
00:45:59,130 --> 00:45:59,460
Benar.

846
00:45:59,460 --> 00:46:00,970
Warna apa yang Anda
dapatkan sebelumnya?

847
00:46:00,970 --> 00:46:02,150
AUDIENS: Biru.

848
00:46:02,150 --> 00:46:03,050
SRINIVAS DEVADAS: Anda
dapat biru sebelumnya?

849
00:46:03,050 --> 00:46:03,800
Baiklah

850
00:46:03,800 --> 00:46:04,890
Ya Anda dapat ungu.

851
00:46:04,890 --> 00:46:06,190
Anda memiliki sebuah set.

852
00:46:06,190 --> 00:46:09,220
Sebenarnya kita mempunyai yang merah ini
yang berharga, yang--

853
00:46:09,220 --> 00:46:12,780
tidak, kita tidak punya.

854
00:46:12,780 --> 00:46:14,479
Kita memutuskan untuk tidak membuat merah.

855
00:46:14,479 --> 00:46:15,020
Saya tidak tahu.

856
00:46:15,020 --> 00:46:17,370
Ada suatu pesan
bawah sadar

857
00:46:17,370 --> 00:46:20,750
saya rasa dengan melempar
Frisbee merah yang tidak kita sukai.

858
00:46:20,750 --> 00:46:21,380
Tapi OK.

859
00:46:21,380 --> 00:46:22,550
Jadi terima kasih.

860
00:46:22,550 --> 00:46:33,260
Dan secara sederhana h(x)
adalah sesuatu di mana

861
00:46:33,260 --> 00:46:37,360
Saya akan menyambungkan
sebuah nol ke nilai x.

862
00:46:37,360 --> 00:46:38,660
dan menaruhnya begitu saja.

863
00:46:38,660 --> 00:46:40,810
Dan jelas ini
merusak ke-satu-arah-an

864
00:46:40,810 --> 00:46:43,610
karena saya hanya mengambil
masukannya, saya menambahkan sebuah nol terhadapnya,

865
00:46:43,610 --> 00:46:44,730
dan mengeluarkannya.

866
00:46:44,730 --> 00:46:46,900
Jadi ini akan menjadi mudah
untuk mundur, benar?

867
00:46:46,900 --> 00:46:53,500
Dan ini hanya terjadi
jika x kurang dari n,

868
00:46:53,500 --> 00:46:55,460
seperti yang dikatakan pria itu.

869
00:46:55,460 --> 00:47:00,220
Kurang dari atau sama dengan n dalam
arti panjang masukannya, OK?

870
00:47:00,220 --> 00:47:03,131
Jika tidak saya
akan melakukan h(x).

871
00:47:08,270 --> 00:47:10,160
Jadi ini berita bagus.

872
00:47:10,160 --> 00:47:15,400
Karena sebenarnya saya menggunakan
fungsi hash dalam kasus

873
00:47:15,400 --> 00:47:17,890
di mana saya punya sebuah
masukan string yang lebih panjang.

874
00:47:17,890 --> 00:47:20,660
Ini berita buruk untuk
ke-satu-arah-an karena saya hanya

875
00:47:20,660 --> 00:47:23,010
meneruskan masukannya.

876
00:47:23,010 --> 00:47:30,927
Dan jadi jika saya mendapatkan sebuah x, dan saya
melihat apakah x tersebut ada di luar sini,

877
00:47:30,927 --> 00:47:32,510
dan mari katakan
demi argumen

878
00:47:32,510 --> 00:47:38,480
tersebut-- Anda bisa
katakan bahwa n

879
00:47:38,480 --> 00:47:43,330
akan menjadi sesuatu 
yang kurang dari d,

880
00:47:43,330 --> 00:47:46,210
yang merupakan keluaran
terakhir, yang memiliki d-bit.

881
00:47:46,210 --> 00:47:49,090
Jadi jika Anda melihat sesuatu
yang dihasilkan h aksen

882
00:47:49,090 --> 00:47:51,450
yang kurang dari
d-bit Anda langsung

883
00:47:51,450 --> 00:47:54,030
tahu bahwa Anda dapat
mundur dan menemukan

884
00:47:54,030 --> 00:47:57,186
masukan apa yang menghasilkan
hal tersebut untuk h aksen, benar?

885
00:47:57,186 --> 00:47:59,060
Karena Anda hanya pergi
dan Anda mundur.

886
00:47:59,060 --> 00:48:00,350
Inilah yang diberitahu kepada Anda.

887
00:48:00,350 --> 00:48:01,850
Sekarang di sisi lain
jika dia lebih besar

888
00:48:01,850 --> 00:48:03,160
jelas Anda tidak bisa melakukan hal itu.

889
00:48:03,160 --> 00:48:06,770
Tapi ada
banyak kombinasi

890
00:48:06,770 --> 00:48:08,100
yang dapat Anda lakukan untuk hal itu.

891
00:48:08,100 --> 00:48:11,300
Jadi ini merusak ke-satu-arah-an, OK?

892
00:48:11,300 --> 00:48:13,074
Sekarang Anda pikirkan tentang TCR.

893
00:48:13,074 --> 00:48:14,490
Dan hal yang Anda inginkan
tunjukkan tentu saja

894
00:48:14,490 --> 00:48:17,570
adalah hal ini mempertahankan TCR.

895
00:48:17,570 --> 00:48:20,622
Jadi itu adalah hal terakhir
yang harus kita tunjukkan.

896
00:48:20,622 --> 00:48:22,080
Kita tahu bahwa hal ini
merusak ke-satu-arah-an.

897
00:48:22,080 --> 00:48:25,182
Tetapi jika hal ini merusak TCR, kita belum
memiliki contoh kita.

898
00:48:25,182 --> 00:48:26,640
Jadi kita ingin menunjukkan
bahwa hal ini sebenarnya

899
00:48:26,640 --> 00:48:31,220
mempertahankan TCR, yang merupakan
sejenis properti lemah

900
00:48:31,220 --> 00:48:33,440
yang perlu kita pertahankan.

901
00:48:33,440 --> 00:48:35,890
Dan alasan hal
ini mempertahankan TCR

902
00:48:35,890 --> 00:48:39,290
adalah jelas bahwa hanya ada
dua kasus di sini,

903
00:48:39,290 --> 00:48:41,720
sesuai dengan
pernyataan if tersebut.

904
00:48:41,720 --> 00:48:49,280
Dan cukup jelas bahwa jika
x kurang dari atau sama dengan n,

905
00:48:49,280 --> 00:49:03,520
jelas nilai-nilai x yang berbeda akan menghasilkan
nilai-nilai h'(x) yang berbeda, benar?

906
00:49:03,520 --> 00:49:06,620
Karena saya hanya meneruskan
nilai x hingga menjadi keluaran.

907
00:49:06,620 --> 00:49:09,730
Jadi jika x kurang dari n saya
akan mendapatkan hash-hash yang berbeda

908
00:49:09,730 --> 00:49:10,570
pada keluarannya.

909
00:49:10,570 --> 00:49:12,350
Saya hanya menyalurkannya.

910
00:49:12,350 --> 00:49:13,940
Jadi itu mudah.

911
00:49:13,940 --> 00:49:17,490
Dan untuk kasus lainnya,
saya berasumsi bahwa h(x)

912
00:49:17,490 --> 00:49:20,129
adalah CCR, benar?

913
00:49:20,129 --> 00:49:22,420
Karena itu adalah asumsi 
awalnya, bahwa saya mempunyai h,

914
00:49:22,420 --> 00:49:23,540
yang CCR.

915
00:49:23,540 --> 00:49:30,690
Jadi dalam kedua kasus TCR
dipertahankan karena lainnya h(x)

916
00:49:30,690 --> 00:49:38,350
mempertahankan TCR, OK?

917
00:49:38,350 --> 00:49:41,284
Jadi sekali lagi, sedikit
contoh yang dibuat-buat

918
00:49:41,284 --> 00:49:42,700
untuk menunjukkan kepada Anda
perbedaan antara

919
00:49:42,700 --> 00:49:45,510
properti-properti yang berbeda ini sehingga
Anda tahu untuk tidak mencampur mereka.

920
00:49:45,510 --> 00:49:47,630
Anda tahu apa yang
ingin Anda minta,

921
00:49:47,630 --> 00:49:51,150
hal yang dibutuhkan
ketika Anda benar-benar

922
00:49:51,150 --> 00:49:53,870
mengimplementasikan sebuah
aplikasi yang bergantung

923
00:49:53,870 --> 00:49:56,000
pada properti-properti tertentu.

924
00:49:56,000 --> 00:49:57,230
OK?

925
00:49:57,230 --> 00:49:59,010
Ada pertanyaan sejauh ini
mengenai properti-properti

926
00:49:59,010 --> 00:50:01,040
atau salah satu contoh ini?

927
00:50:01,040 --> 00:50:03,227
Kita akan membahas
penggunaan mereka.

928
00:50:06,970 --> 00:50:08,510
OK.

929
00:50:08,510 --> 00:50:12,170
Jadi mulai memikirkan
keamanan komputer.

930
00:50:12,170 --> 00:50:18,090
Mulai pikirkan para peretas,
melindungi diri Anda

931
00:50:18,090 --> 00:50:20,655
dari orang-orang jahat
di luar sana yang

932
00:50:20,655 --> 00:50:22,640
mencoba untuk mengetahui
kata sandi Anda,

933
00:50:22,640 --> 00:50:24,924
mencoba untuk merusak
berkas-berkas Anda, secara umum

934
00:50:24,924 --> 00:50:25,965
membuat hidup Anda sengsara.

935
00:50:32,880 --> 00:50:38,880
Dan kita akan mulai dengan
contoh-contoh yang sederhana, di mana

936
00:50:38,880 --> 00:50:41,730
properti-propertinya
cukup jelas,

937
00:50:41,730 --> 00:50:46,205
dan meningkat hingga contoh
penawaran lelang ini yang

938
00:50:46,205 --> 00:50:48,080
seharusnya seperti
puncak dari setidaknya

939
00:50:48,080 --> 00:50:50,120
perkuliahan bagian ini.

940
00:50:50,120 --> 00:50:52,470
Dan bergantung pada berapa
banyak waktu yang saya miliki

941
00:50:52,470 --> 00:50:54,800
saya akan memberitahu Anda
sedikit mengenai bagaimana

942
00:50:54,800 --> 00:50:56,730
cara mengimplementasikan fungsi-fungsi hash.

943
00:50:56,730 --> 00:50:59,640
Tapi saya pikir
hal-hal ini lebih

944
00:50:59,640 --> 00:51:03,580
penting dari sudut pandang
yang memberikan Anda

945
00:51:03,580 --> 00:51:08,610
sebuah gambaran dari hash kriptografik.

946
00:51:08,610 --> 00:51:10,380
Baiklah.

947
00:51:10,380 --> 00:51:11,970
Penyimpanan kata sandi.

948
00:51:11,970 --> 00:51:16,730
Berapa banyak dari Anda menulis
kata sandi Anda di sebuah berkas

949
00:51:16,730 --> 00:51:22,230
tidak terenkripsi dan menyimpannya di
sebuah tempat yang dapat dibaca?

950
00:51:22,230 --> 00:51:24,380
Itu dia.

951
00:51:24,380 --> 00:51:27,390
Terima kasih sudah jujur.

952
00:51:27,390 --> 00:51:29,550
Dan saya melakukan yang lebih parah.

953
00:51:29,550 --> 00:51:32,610
Saya bukan hanya melakukan itu, saya
menggunakan nama anak perempuan pertama saya

954
00:51:32,610 --> 00:51:35,334
untuk empat kata sandi saya.

955
00:51:35,334 --> 00:51:36,750
Saya tidak akan memberitahu
Anda namanya.

956
00:51:41,350 --> 00:51:43,470
Jadi itu sesuatu yang ingin
kita perbaiki, benar?

957
00:51:43,470 --> 00:51:45,500
Jadi apa yang dilakukan sistem-sistem nyata?

958
00:51:45,500 --> 00:51:49,530
Sistem-sistem nyata tidak dapat melarang
saya untuk menggunakan nama

959
00:51:49,530 --> 00:51:51,400
anak perempuan pertama saya sebagai
kata sandi saya, benar?

960
00:51:51,400 --> 00:51:53,580
Jadi tidak ada cara Anda dapat
berlindung dari hal itu.

961
00:51:53,580 --> 00:51:56,830
Tapi jika saya memiliki sebuah
kata sandi masuk akal, yang

962
00:51:56,830 --> 00:51:59,030
memiliki entropi yang
masuk akal di dalamnya-- jadi

963
00:51:59,030 --> 00:52:01,344
mari asumsikan di sini bahwa kita
memiliki entropi yang masuk akal

964
00:52:01,344 --> 00:52:02,010
dalam kata sandi tersebut.

965
00:52:02,010 --> 00:52:04,000
Dan Anda dapat katakan saja 128-bit.

966
00:52:04,000 --> 00:52:05,240
Dan hal itu tidak banyak, benar?

967
00:52:05,240 --> 00:52:09,135
128-bit adalah 16 karakter, OK?

968
00:52:09,135 --> 00:52:11,260
Dan Anda tidak harus menjawab
ini-- berapa banyak dari kalian

969
00:52:11,260 --> 00:52:15,390
memiliki 16 karakter
dalam kata sandi kalian?

970
00:52:15,390 --> 00:52:16,710
Oh saya kagum.

971
00:52:16,710 --> 00:52:17,350
OK.

972
00:52:17,350 --> 00:52:18,980
Jadi Anda memiliki
entropi 128-bit.

973
00:52:18,980 --> 00:52:21,710
Tapi untuk kalian yang lain, lupakan.

974
00:52:21,710 --> 00:52:25,040
Hal ini tidak akan
membantu Anda, OK?

975
00:52:25,040 --> 00:52:28,140
Tapi hal yang saya inginkan,
mengasumsikan Anda memiliki

976
00:52:28,140 --> 00:52:31,830
entropi signifikan pada kata sandi
Anda-- karena jika tidak,

977
00:52:31,830 --> 00:52:33,940
jika tidak ada entropi
yang cukup Anda

978
00:52:33,940 --> 00:52:38,272
dapat menghitung semua kemungkinan
kata sandi yang terdiri dari delapan huruf.

979
00:52:38,272 --> 00:52:39,230
Dan hal itu tidak terlalu banyak.

980
00:52:39,230 --> 00:52:41,391
Hal tersebut merupakan 2 pangkat
50, mirip seperti itu.

981
00:52:41,391 --> 00:52:42,390
Dan Anda dapat lanjutkan terus.

982
00:52:42,390 --> 00:52:44,150
Dan tak satupun dari
properti-properti ini berarti.

983
00:52:44,150 --> 00:52:45,810
Anda hanya-- Anda hanya memiliki h(x) Anda.

984
00:52:45,810 --> 00:52:48,206
Hal ini publik.

985
00:52:48,206 --> 00:52:50,080
Kita akan membahas tentang cara kita
menggunakan hal tersebut sebentar lagi.

986
00:52:50,080 --> 00:52:53,350
Tapi jelas jika
domainnya kecil

987
00:52:53,350 --> 00:52:55,120
Anda bisa sekedar
menelusuri domain.

988
00:52:55,120 --> 00:52:57,062
Jadi ingatlah itu.

989
00:52:57,062 --> 00:52:58,770
Saya sudah bicara soal h(x), 
dan sudah jelas

990
00:52:58,770 --> 00:53:00,300
itu akan relevan di sini.

991
00:53:00,300 --> 00:53:02,520
Tapi anggap saja Saya ingin 
membangun sebuah sistem,

992
00:53:02,520 --> 00:53:04,300
dan inilah cara 
sistem ini dibangun,

993
00:53:04,300 --> 00:53:06,700
ETC garis miring password
file, diasumsikan

994
00:53:06,700 --> 00:53:11,040
Anda punya password panjang
akan dilakukan seperti ini,

995
00:53:11,040 --> 00:53:13,320
jika tidak akan membutuhkan sesuatu
yang dinamakan salt (garam).

996
00:53:13,320 --> 00:53:16,540
Tapi itu 6, 8, 57
dan kita tidak akan kesana.

997
00:53:16,540 --> 00:53:19,590
Jadi kita hanya berasumsi
sebuah entropi yang besar.

998
00:53:19,590 --> 00:53:21,980
Apa yang bisa dilakukan sebuah sistem?

999
00:53:21,980 --> 00:53:26,210
Di mana dia bisa disimpan agar
bisa mengizinkan Anda masuk,

1000
00:53:26,210 --> 00:53:28,830
hanya jika ketika
Anda mengetik kata sandi,

1001
00:53:28,830 --> 00:53:32,190
dan tidak membiarkan kata sandi palsu
digunakan untuk masuk ke sistem?

1002
00:53:32,190 --> 00:53:34,610
Atau sesorang dengan kata sandi palsu
masuk ke dalam sistem.

1003
00:53:34,610 --> 00:53:35,249
Ya, silakan.

1004
00:53:35,249 --> 00:53:37,540
AUDIENS: Jika Anda menangkap
kata sandi palsu saat Anda memasukkannya

1005
00:53:37,540 --> 00:53:39,380
dan dibandingkan dengan 
apa yang disimpan--

1006
00:53:39,380 --> 00:53:40,347
SRINIVAS DEVADAS: Ya.

1007
00:53:40,347 --> 00:53:42,430
AUDIENS: Jika itu hash satu arah, 
Anda tahu Anda memiliki

1008
00:53:42,430 --> 00:53:42,730
kata sandi yang benar.

1009
00:53:42,730 --> 00:53:43,820
SRINIVAS DEVADAS:
Itu benar sekali.

1010
00:53:43,820 --> 00:53:44,790
Itu benar.

1011
00:53:44,790 --> 00:53:49,950
Jadi itu merupakan ide yang sangat sederhana,
ide yang sangat kuat.

1012
00:53:49,950 --> 00:53:54,610
Seperti yang saya katakan, mengasumsikan bahwa
entropi-- dan saya menjelaskan

1013
00:53:54,610 --> 00:53:56,890
yang sudah jelas sekarang--
tapi ini sangat penting

1014
00:53:56,890 --> 00:53:59,890
ketika Anda berbicara tentang keamanan
untuk menyatakan asumsi Anda.

1015
00:53:59,890 --> 00:54:04,380
Tetapi Anda tidak menyimpan 
kata sandi di komputer Anda.

1016
00:54:04,380 --> 00:54:06,940
Dan Anda menyimpan
hash dari password tersebut.

1017
00:54:06,940 --> 00:54:09,530
Sekarang, kenapa saya menyimpan
kata sandi di komputer?

1018
00:54:09,530 --> 00:54:12,200
Karena ini sangat
merepotkan, bukan?

1019
00:54:12,200 --> 00:54:15,180
Jadi ini yang sistem
lakukan untuk Anda.

1020
00:54:15,180 --> 00:54:18,110
Tetapi, inti masalahnya adalah
jika saya kehilangan password saya,

1021
00:54:18,110 --> 00:54:19,470
Ini tidak membantu saya.

1022
00:54:19,470 --> 00:54:24,050
Karena sistem menginginkan Anda
untuk memilih sebuah kata sandi

1023
00:54:24,050 --> 00:54:26,720
yang cukup panjang,
serta h-nya satu arah(one-way).

1024
00:54:26,720 --> 00:54:30,960
Jadi siapapun yang menemukan h dari
PW yang dapat dibaca secara publik

1025
00:54:30,960 --> 00:54:33,840
tidak dapat menemukan PW, kan?

1026
00:54:33,840 --> 00:54:36,420
Inilah yang keren tentang hal ini.

1027
00:54:36,420 --> 00:54:38,740
Bagaimana Anda mengizinkan
orang tersebut log in?

1028
00:54:38,740 --> 00:54:47,860
Gunakan h dari PW untuk dibandingkan
dengan h dari PW aksen,

1029
00:54:47,860 --> 00:54:54,420
yaitu apa yang dimasukan, dimana 
PW aksen perupakan kata sandi yang diketik.

1030
00:55:00,540 --> 00:55:08,530
Dan jelas yang kita perlukan
adalah pengungkapan h dari PW

1031
00:55:08,530 --> 00:55:14,960
tidak boleh mengungkap PW.

1032
00:55:14,960 --> 00:55:19,570
Jadi kita pasti membutuhkan 
sifat satu arah.

1033
00:55:19,570 --> 00:55:24,370
Bagaimana tentang-- bagaimana
tentang Collision Resistance?

1034
00:55:24,370 --> 00:55:28,340
Target collision resistance kita?

1035
00:55:28,340 --> 00:55:31,350
Sekarang, berpikirlah secara praktis, oke?

1036
00:55:31,350 --> 00:55:33,590
Apakah kita tertarik tentang 
fungsi hash ini

1037
00:55:33,590 --> 00:55:34,880
bersifat collision resistant?

1038
00:55:34,880 --> 00:55:37,150
Apa artinya
dalam kasus ini?

1039
00:55:37,150 --> 00:55:40,315
Beri saya konteks dalam
aplikasi khusus ini?

1040
00:55:40,315 --> 00:55:40,940
Ya, silakan.

1041
00:55:40,940 --> 00:55:44,860
AUDIENS: Artinya seseorang
yang memasukkan kata sandi yang berbeda

1042
00:55:44,860 --> 00:55:47,107
akan memiliki
hash yang sama [TIDAK TERDENGAR]

1043
00:55:47,107 --> 00:55:48,190
SRINIVAS DEVADAS: Tepat.

1044
00:55:48,190 --> 00:55:56,600
Jadi itu berarti bahwa apa yang Anda hadapi
adalah sebuah situasi di mana Anda tidak

1045
00:55:56,600 --> 00:56:00,900
mengungkapkan-- dan apa yang mungkin
terjadi adalah h dari PW aksen

1046
00:56:00,900 --> 00:56:02,460
sama dengan h dari PW

1047
00:56:02,460 --> 00:56:07,190
Tapi h dari PW sama dengan
h dari PW aksen.

1048
00:56:07,190 --> 00:56:11,490
Tapi PW tidak sama dengan PW aksen.

1049
00:56:11,490 --> 00:56:13,950
Apa yang Anda punya adalah
false positive (kesimpulan positif yang salah).

1050
00:56:13,950 --> 00:56:15,570
Seseorang yang tidak tahu
kata sandi Anda

1051
00:56:15,570 --> 00:56:19,060
tapi menebak benar-- dan
ini adalah sebuah nilai 128-bit,

1052
00:56:19,060 --> 00:56:22,840
dan mereka menebak dengan benar--
mereka akan masuk.

1053
00:56:22,840 --> 00:56:24,940
Anda tidak perlu terlalu
peduli terhadap kemungkinan

1054
00:56:24,940 --> 00:56:26,190
dari kejadian ini.

1055
00:56:26,190 --> 00:56:27,900
Itu sangat kecil.

1056
00:56:27,900 --> 00:56:30,570
Biasanya Anda akan punya
sistem-sistem yang mengunci Anda keluar

1057
00:56:30,570 --> 00:56:34,770
jika Anda mencoba 10 percobaan yang terjadi
satu, dua, kata sandi yang salah,

1058
00:56:34,770 --> 00:56:35,270
benar?

1059
00:56:35,270 --> 00:56:37,965
Jadi sebenarnya dalam sistem 
Anda tidak memerlukan

1060
00:56:37,965 --> 00:56:39,340
Anda ingin
membangun sistem yang

1061
00:56:39,340 --> 00:56:42,090
memiliki
properti minimal dalam hal

1062
00:56:42,090 --> 00:56:43,570
batasan yang digunakan.

1063
00:56:43,570 --> 00:56:47,090
Jadi dari sudut pandang
pembangunan sistem ini hanya membutuhkan OW.

1064
00:56:47,090 --> 00:56:48,350
Jangan berlebihan.

1065
00:56:48,350 --> 00:56:53,100
Tidak memerlukan collision
resistance atau TCR, OK?

1066
00:56:53,100 --> 00:56:55,420
Mari kita lakukan contoh
yang sedikit berbeda.

1067
00:56:55,420 --> 00:56:59,010
Juga sedikit
pemanasan untuk apa

1068
00:56:59,010 --> 00:57:01,895
yang akan terjadi selanjutnya, yaitu
pendeteksi file yang telah dimodifikasi.

1069
00:57:22,080 --> 00:57:32,800
Jadi untuk setiap file F, Saya akan
menyimpan h dari F. Dan dengan aman.

1070
00:57:32,800 --> 00:57:36,980
Jadi Anda berasumsi bahwa ini berarti
h dari F tidak dapat dimodifikasi

1071
00:57:36,980 --> 00:57:40,380
oleh siapa saja, h dari F itu sendiri.

1072
00:57:47,860 --> 00:57:56,030
Dan sekarang kita ingin
memeriksa apakah F dimodifikasi

1073
00:57:56,030 --> 00:58:04,470
dengan menghitung ulang h dari F. 
Yang bisa jadi,

1074
00:58:04,470 --> 00:58:05,640
ini bisa saja sudah dimodifikasi.

1075
00:58:05,640 --> 00:58:07,130
Jadi ini sebenarnya 
bisa menjadi F aksen.

1076
00:58:07,130 --> 00:58:09,250
Anda tidak tahu itu.

1077
00:58:09,250 --> 00:58:10,500
Anda memiliki sebuah file.

1078
00:58:10,500 --> 00:58:11,780
Ukurannya satu gigabyte.

1079
00:58:11,780 --> 00:58:14,270
Dan seseorang mungkin
telah merusak

1080
00:58:14,270 --> 00:58:16,030
salah satu bit dalam file.

1081
00:58:16,030 --> 00:58:19,340
Yang Anda miliki 
hanyalah digest dari d-bit itu

1082
00:58:19,340 --> 00:58:23,670
sesuai dengan h dari F yang Anda
simpan di lokasi yang aman.

1083
00:58:23,670 --> 00:58:27,190
Dan Anda ingin memeriksa
untuk melihat, dengan cara dikomputasi ulang

1084
00:58:27,190 --> 00:58:31,940
h dari F, dari file
yang diberikan kepada Anda,

1085
00:58:31,940 --> 00:58:34,135
dan membandingkannya dengan apa
yang telah anda simpan, h dari F

1086
00:58:34,135 --> 00:58:35,730
yang anda simpan.

1087
00:58:35,730 --> 00:58:42,200
Jadi properti apa yang kita
perlukan untuk dapat melakukan hal tersebut?

1088
00:58:42,200 --> 00:58:44,590
Dengan fungsi hash.

1089
00:58:44,590 --> 00:58:48,070
Apa tepatnya yang kita 
perlukan untuk dapat melakukan hal tersebut?

1090
00:58:50,620 --> 00:58:53,040
Apa yang ingin dilakukan
oleh penyerang?

1091
00:58:53,040 --> 00:58:55,530
Apa yang dimaksud dengan pembobolan yang sukses?

1092
00:58:55,530 --> 00:59:02,000
Sebuah pembobolan yang sukses terjadi jika
musuh bisa memodifikasi file

1093
00:59:02,000 --> 00:59:08,720
dan h dari F tetap sama, ya kan?

1094
00:59:08,720 --> 00:59:10,780
Itu merupakan 
perusakan yang sukses, ya kan?

1095
00:59:10,780 --> 00:59:13,600
Ya.

1096
00:59:13,600 --> 00:59:14,125
Silakan.

1097
00:59:14,125 --> 00:59:14,910
AUDIENS: TCR.

1098
00:59:14,910 --> 00:59:15,550
SRINIVAS DEVADAS: TCR?

1099
00:59:15,550 --> 00:59:16,300
Ya, tentu saja.

1100
00:59:16,300 --> 00:59:16,841
Anda memerlukan TCR.

1101
00:59:19,350 --> 00:59:21,750
Jadi Anda ingin memodifikasi filenya.

1102
00:59:34,830 --> 00:59:38,230
Jadi Anda diberikan 
file-- si penyerang

1103
00:59:38,230 --> 00:59:41,980
diberikan file tersebut, yang
merupakan input ke hash,

1104
00:59:41,980 --> 00:59:47,550
dan akan mencoba dan
memodifikasi-- memodifikasi filenya, bukan?

1105
00:59:47,550 --> 00:59:51,130
Jadi mari lakukan beberapa lagi.

1106
00:59:51,130 --> 00:59:57,470
Dan kita akan mengembangkan
kebutuhan kita disini sedikit.

1107
00:59:57,470 --> 01:00:00,891
Jadi keduanya adalah
properti dasar.

1108
01:00:00,891 --> 01:00:02,140
Saya ingin meninggalkan ini diatas sana.

1109
01:00:04,937 --> 01:00:06,770
Kita akan melakukan
sesuatu yang berhubungan dengan

1110
01:00:06,770 --> 01:00:08,690
tanda tangan digital.

1111
01:00:08,690 --> 01:00:13,030
Jadi tanda tangan digital ialah
penemuan indah

1112
01:00:13,030 --> 01:00:18,290
yang keluar dari MIT dalam
laboratorium ilmu komputer--

1113
01:00:18,290 --> 01:00:23,160
lagi-lagi, Ron Rivest dan
kolaborator-kolaboratornya-- di mana

1114
01:00:23,160 --> 01:00:28,120
sebuah cara menandatangani dokumen
secara digital dengan menggunakan

1115
01:00:28,120 --> 01:00:31,170
sebuah kunci rahasia, kunci privat.

1116
01:00:31,170 --> 01:00:35,660
Namun siapapun yang punya
akses ke sebuah kunci publik,

1117
01:00:35,660 --> 01:00:37,210
jadi itu bisa jadi
siapa saja,

1118
01:00:37,210 --> 01:00:41,647
dapat memverifikasi keaslian
tanda tangan tersebut, betul?

1119
01:00:41,647 --> 01:00:43,230
Jadi itulah
tanda tangan digital.

1120
01:00:52,490 --> 01:00:55,960
Jadi kita akan membahas
mengenai kriptografi publik

1121
01:00:55,960 --> 01:01:00,730
pada hari Kamis, berkenaan dengan
bagaimana Anda bisa membangun

1122
01:01:00,730 --> 01:01:06,640
sistem atau algoritma enkripsi
yang merupakan algoritma kunci publik.

1123
01:01:06,640 --> 01:01:12,470
Tapi di sini saya hanya akan memberitahu Anda
apa yang kita inginkan dari hal tersebut.

1124
01:01:12,470 --> 01:01:15,100
Pada dasarnya apa yang kita miliki di sini
dalam hal tanda tangan,

1125
01:01:15,100 --> 01:01:18,100
Kami sebenarnya ingin berbicara
tentang enkripsi di sini,

1126
01:01:18,100 --> 01:01:20,180
adalah-- ada dua
kunci yang terasosiasi

1127
01:01:20,180 --> 01:01:24,030
dengan sistem kunci publik.

1128
01:01:24,030 --> 01:01:26,880
Siapa saja dan semua orang
dalam sistem

1129
01:01:26,880 --> 01:01:31,090
akan memiliki kunci publik yang
dapat Anda masukkan ke situs web Anda.

1130
01:01:31,090 --> 01:01:34,500
Dan Anda juga memiliki kunci rahasia--
seperti kata sandi Anda--

1131
01:01:34,500 --> 01:01:35,930
yang tidak ingin
Anda tulis,

1132
01:01:35,930 --> 01:01:38,221
anda tidak ingin menyebarkannya,
karena secara efektif itulah

1133
01:01:38,221 --> 01:01:39,930
identitas anda.

1134
01:01:39,930 --> 01:01:44,700
Dan tanda tangan digital
berhubungan dengan hal bahwa

1135
01:01:44,700 --> 01:01:46,880
Anda mempunyai
dua operasi.

1136
01:01:46,880 --> 01:01:51,030
Anda memiliki operasi tanda tangan (signing)
dan verifikasi (verification)

1137
01:01:51,030 --> 01:01:56,760
Jadi signing berarti Anda
menciptakan suatu tanda tangan sigma yang

1138
01:01:56,760 --> 01:02:06,420
merupakan tanda menggunakan kunci
privat Anda, kunci rahasia Anda,

1139
01:02:06,420 --> 01:02:10,070
dari pesan M. Jadi Anda berkata
berkata ini adalah pesan ini,

1140
01:02:10,070 --> 01:02:12,060
ini datang dari saya, iya kan?

1141
01:02:12,060 --> 01:02:13,655
Itulah yang dimaksud dengan signin.

1142
01:02:13,655 --> 01:02:16,030
Anda memiliki pesan yang panjang ini
dan anda menandatanganinya di bawah.

1143
01:02:16,030 --> 01:02:20,620
Anda bertanggung jawab atas
isi dari pesan tersebut.

1144
01:02:20,620 --> 01:02:27,710
Dan kemudian verifikasinya yaitu
Anda memiliki M sigma dan kunci publik.

1145
01:02:27,710 --> 01:02:31,770
Dan ini hanya akan
menghasilkan true atau false.

1146
01:02:35,780 --> 01:02:42,260
Jadi kunci publik seharusnya
tidak memberitahukan informasi apa pun

1147
01:02:42,260 --> 01:02:43,260
mengenai kunci rahasia.

1148
01:02:48,570 --> 01:02:51,700
Dan itulah tantangan untuk
membangun sistem PKI,

1149
01:02:51,700 --> 01:02:56,800
yang akan kita bicarakan
secara rinci lain kali.

1150
01:02:56,800 --> 01:03:01,440
Tapi kita tidak perlu
memikirkannya

1151
01:03:01,440 --> 01:03:06,100
selain mengakuinya hari ini.

1152
01:03:06,100 --> 01:03:09,680
Jadi kunci publik dan privat
merupakan dua hal yang berbeda,

1153
01:03:09,680 --> 01:03:12,150
tidak ada yang mengungkapkan
apa pun tentang satu sama lain.

1154
01:03:12,150 --> 01:03:14,430
Anggaplah keduanya sepenuhnya
kata sandi yang berbeda.

1155
01:03:14,430 --> 01:03:16,730
Tetapi keduanya kebetulan
berhubungan secara matematis.

1156
01:03:16,730 --> 01:03:18,500
Itu sebabnya ini
semuanya bekerja.

1157
01:03:18,500 --> 01:03:20,260
Dan hubungan matematis
tersebut

1158
01:03:20,260 --> 01:03:24,750
akan kita lihat secara
detail hari Kamis.

1159
01:03:24,750 --> 01:03:26,920
Tapi, setelah mengatakan 
itu, lihatlah

1160
01:03:26,920 --> 01:03:29,490
apa yang aplikasi ini
lakukan untuk kita, benar?

1161
01:03:29,490 --> 01:03:31,370
Ini merupakan sebuah aplikasi keamanan.

1162
01:03:31,370 --> 01:03:33,930
Dan saya bahkan belum
sampai ke fungsi hash.

1163
01:03:33,930 --> 01:03:36,600
Tapi saya akan ke sana
sebentar lagi.

1164
01:03:36,600 --> 01:03:39,330
Tapi yang ingin saya lakukan adalah
menekankan bahwa ada

1165
01:03:39,330 --> 01:03:41,150
dua operasi yang sedang berlangsung.

1166
01:03:41,150 --> 01:03:42,760
Pertama yang merupakan
tanda tangan, yang

1167
01:03:42,760 --> 01:03:46,050
merupakan tanda tangan privat, dalam
artian tanda tangannya privat bagi saya,

1168
01:03:46,050 --> 01:03:47,160
jika saya adalah Alice.

1169
01:03:47,160 --> 01:03:48,500
Atau privat untuk Alice.

1170
01:03:48,500 --> 01:03:50,590
Dan Anda sedang menggunakan
informasi rahasia

1171
01:03:50,590 --> 01:03:52,810
pada pesan publik M,
karena itulah

1172
01:03:52,810 --> 01:03:54,690
yang akan dipublikasikan.

1173
01:03:54,690 --> 01:03:57,580
Dan Anda akan menandatangani
pesan publik tersebut.

1174
01:03:57,580 --> 01:04:01,160
Dan kemudian semua orang di
dunia yang memiliki akses

1175
01:04:01,160 --> 01:04:04,190
terhadap kunci publik key Alice
dapat mengatakan bahwa,

1176
01:04:04,190 --> 01:04:06,840
oh, saya sedang melihat tanda tangannya,
yang berupa kumpulan bit.

1177
01:04:06,840 --> 01:04:09,900
Saya sedang melihat tanda tangannya,
yang berupa kumpulan bit.

1178
01:04:09,900 --> 01:04:12,590
Dan saya punya kunci publik ini,
yang berupa kumpulan bit.

1179
01:04:12,590 --> 01:04:16,150
Dan saya dengan yakin
dapat mengatakan

1180
01:04:16,150 --> 01:04:19,340
bahwa antara Alice
yang menandatangani pesan ini,

1181
01:04:19,340 --> 01:04:22,560
atau Alice tidak
menandatangani pesan ini.

1182
01:04:22,560 --> 01:04:26,710
Dan asumsi
di sini adalah bahwa Alice

1183
01:04:26,710 --> 01:04:28,950
merahasiakan kunci privatnya.

1184
01:04:28,950 --> 01:04:30,970
Dan tentu saja, apa
yang baru saja saya tulis di sana,

1185
01:04:30,970 --> 01:04:33,450
bahwa kunci publik
tidak mengungkapkan apapun

1186
01:04:33,450 --> 01:04:35,530
tentang kunci rahasia, oke?

1187
01:04:35,530 --> 01:04:38,350
Jadi itu merupakan tanda tangan digital
untuk Anda, singkatnya.

1188
01:04:38,350 --> 01:04:40,990
Dan ketika Anda membuat sertifikat
MIT, Anda

1189
01:04:40,990 --> 01:04:45,130
menggunakan tanda tangan digital ala
Rivest-Shamir-Adleman, algoritma

1190
01:04:45,130 --> 01:04:45,900
RSA.

1191
01:04:45,900 --> 01:04:48,580
Jadi Anda menggunakan
ini selalu,

1192
01:04:48,580 --> 01:04:52,290
saat Anda mengklik
tautan 6.046, misalnya.

1193
01:04:52,290 --> 01:04:56,440
Dan yang terjadi adalah M
biasanya sangat besar.

1194
01:04:56,440 --> 01:04:58,060
Maksud saya, itu bisa
berupa file, kan?

1195
01:04:58,060 --> 01:04:59,510
Itu bisa berupa file besar.

1196
01:04:59,510 --> 01:05:02,730
Dan Anda tidak perlu
menghitung operasi ini

1197
01:05:02,730 --> 01:05:04,150
pada file yang berukuran besar.

1198
01:05:04,150 --> 01:05:09,580
Jadi untuk kenyamanan, yang terjadi
adalah Anda akhirnya melakukan hashing pada file.

1199
01:05:09,580 --> 01:05:22,550
Dan untuk M besar itu
lebih mudah menandatangani h dari M.

1200
01:05:22,550 --> 01:05:29,810
Dan menggantikan M nya yang
bisa Anda lihat disini dengan h dari M,

1201
01:05:29,810 --> 01:05:30,720
baik?

1202
01:05:30,720 --> 01:05:38,640
Jadi sekarang
kita akan menggunakan h dari M

1203
01:05:38,640 --> 01:05:42,550
di dalam sini, pikirkan
tentang apa yang kita ingin

1204
01:05:42,550 --> 01:05:45,390
kerjakan dengan M, benar?

1205
01:05:45,390 --> 01:05:48,150
Saya sudah beritahu Anda apa yang
kita ingin kerjakan dengan M.

1206
01:05:48,150 --> 01:05:49,360
Ada sebuah pesan tertentu.

1207
01:05:49,360 --> 01:05:50,190
Saya Alice.

1208
01:05:50,190 --> 01:05:53,850
Saya akan menjaga
kunci rahasia saya tetap rahasia.

1209
01:05:53,850 --> 01:05:57,910
Tapi saya ingin berkomitmen pada menandatangani
pesan M ini, baik?

1210
01:05:57,910 --> 01:06:00,330
Dan saya ingin memastikan
bahwa tidak ada siapapun yang

1211
01:06:00,330 --> 01:06:05,320
dapat berpura-pura menjadi saya
yang tidak tahu kunci rahasia saya.

1212
01:06:05,320 --> 01:06:07,290
Dan tidak ada yang tahu.

1213
01:06:07,290 --> 01:06:10,760
Jadi bila saya akan menandatangani
hash dari pesannya,

1214
01:06:10,760 --> 01:06:13,930
sekarang inilah hal yang terpenting
pada kuliah hari ini.

1215
01:06:13,930 --> 01:06:16,680
Saya menandatangani hash
dari pesan h dari M.

1216
01:06:16,680 --> 01:06:22,120
Properti apa yang Saya butuhkan pada
h agar semua ini

1217
01:06:22,120 --> 01:06:23,640
dapat berfungsi?

1218
01:06:23,640 --> 01:06:24,636
Ya, silakan.

1219
01:06:24,636 --> 01:06:26,540
AUDIENS: Apakah itu
non-malleability?

1220
01:06:26,540 --> 01:06:28,665
SRINIVAS DEVADAS: Non
malleability, tetapi bahkan sebelum

1221
01:06:28,665 --> 01:06:31,770
itu-- anggaplah-- tentu saja,
tetapi non-malleability

1222
01:06:31,770 --> 01:06:36,590
merupakan jenis yang berada melebihi salah satu
properti yang di sebelah kanan.

1223
01:06:36,590 --> 01:06:39,570
Anda berada
di jalur yang benar, bukan?

1224
01:06:39,570 --> 01:06:45,219
Jadi apakah Anda ingin memberi
saya jawaban yang berbeda?

1225
01:06:45,219 --> 01:06:46,677
Anda bisa memberi saya
jawaban yang berbeda.

1226
01:06:46,677 --> 01:06:50,090
AUDIENS: Oh, Saya tidak yakin.

1227
01:06:50,090 --> 01:06:52,190
SRINIVAS DEVADAS: Baik.

1228
01:06:52,190 --> 01:06:52,690
Apa?

1229
01:06:52,690 --> 01:06:53,898
Ya, yang di belakang sana.

1230
01:06:53,898 --> 01:06:56,766
AUDIENS: Saya pikir Anda ingin
satu arah karena jika tidak Anda

1231
01:06:56,766 --> 01:07:00,112
dapat mengambil tanda tangan itu dan
menemukan pesan lain yang dapat Anda

1232
01:07:00,112 --> 01:07:01,080
beri kredit.

1233
01:07:01,080 --> 01:07:02,740
SRINIVAS DEVADAS: Saya
bisa membuat M publik.

1234
01:07:02,740 --> 01:07:05,480
Saya dapat membuat M-- M dapat menjadi publik.

1235
01:07:05,480 --> 01:07:07,060
Dan h dari M adalah publik.

1236
01:07:07,060 --> 01:07:13,570
Jadi cara satu-arah bukanlah
cara menarik untuk contoh ini

1237
01:07:13,570 --> 01:07:14,690
jika M adalah publik.

1238
01:07:14,690 --> 01:07:16,690
Dan kita bisa mengasumsikan bahwa M
akhirnya akan menjadi publik.

1239
01:07:16,690 --> 01:07:18,840
Karena itulah pesan yang
saya tanda tangani, ya kan?

1240
01:07:18,840 --> 01:07:21,082
Saya juga bisa mengeluarkan M.

1241
01:07:21,082 --> 01:07:22,540
Jadi saya ingin
hubungannya-- saya ingin

1242
01:07:22,540 --> 01:07:25,760
Anda untuk fokus pada hubungan
antara h dari M dan M

1243
01:07:25,760 --> 01:07:28,720
dan beritahu saya apa yang akan
merusak sistem ini.

1244
01:07:28,720 --> 01:07:31,120
Dan Anda berada di jalur yang benar.

1245
01:07:31,120 --> 01:07:31,970
Ya, silahkan.

1246
01:07:31,970 --> 01:07:32,932
Atau jalan kembali ke sana.

1247
01:07:32,932 --> 01:07:33,890
Ya, maaf tentang itu.

1248
01:07:33,890 --> 01:07:35,074
AUDIENS: TCR.

1249
01:07:35,074 --> 01:07:35,990
SRINIVAS DEVADAS: TCR.

1250
01:07:35,990 --> 01:07:36,780
Kenapa TCR?

1251
01:07:36,780 --> 01:07:37,696
AUDIENS: [TIDAK TERDENGAR]

1252
01:07:46,130 --> 01:07:49,070
SRINIVAS DEVADAS: Jadi saya punya
M. Jadi apa yang terjadi disini--

1253
01:07:49,070 --> 01:07:51,920
Saya harus menulis ini.

1254
01:07:51,920 --> 01:08:12,640
Saya diberi-- sebagai penyerang saya
memiliki M dan h dari M. Tidak baik

1255
01:08:12,640 --> 01:08:33,010
jika Alice menandatangani h dari M, tapi Bob
mengklaim Alice menandatangani M aksen.

1256
01:08:33,010 --> 01:08:39,830
Karena h dari M sama dengan
h dari M aksen, ya kan?

1257
01:08:39,830 --> 01:08:41,600
Itu buruk.

1258
01:08:41,600 --> 01:08:44,729
Jadi M adalah publik--
bisakah Anda berdiri?

1259
01:08:49,229 --> 01:08:50,600
M diberikan.

1260
01:08:50,600 --> 01:08:53,329
Ada M yang spesifik,
dan h yang spesifik

1261
01:08:53,329 --> 01:08:56,470
dari M khususnya,
yang telah terkespos.

1262
01:08:56,470 --> 01:08:59,620
Dan h dari M adalah apa yang
digunakan untuk tanda tangan.

1263
01:08:59,620 --> 01:09:01,140
Jadi Anda ingin menjaga
h dari M tetap sama.

1264
01:09:01,140 --> 01:09:02,170
Ini hal yang spesifik.

1265
01:09:02,170 --> 01:09:03,544
Jadi itu tidak
collision resistance,

1266
01:09:03,544 --> 01:09:05,850
ini target
collision resistance,

1267
01:09:05,850 --> 01:09:07,460
karena itu diberikan kepada Anda.

1268
01:09:07,460 --> 01:09:09,430
Dan Anda ingin
menjaganya tetap sama.

1269
01:09:09,430 --> 01:09:13,600
Tetapi Anda ingin mengklaim bahwa oh,
Anda berjanji kepada saya $10.000, bukan

1270
01:09:13,600 --> 01:09:15,319
$20, benar?

1271
01:09:15,319 --> 01:09:17,899
Jika Anda bisa melakukan itu,
Anda menandatangani dengan mengatakan

1272
01:09:17,899 --> 01:09:22,149
Anda ingin membayar $10.000, bukan
$20, maka Anda mendapat sebuah masalah.

1273
01:09:22,149 --> 01:09:24,160
Jadi yang Anda lakukan sangat dekat.

1274
01:09:24,160 --> 01:09:27,130
Hanya saja itu tidak memerlukan
hubungan yang kuat

1275
01:09:27,130 --> 01:09:28,710
antara 10.000 atau 20.

1276
01:09:28,710 --> 01:09:31,000
Maksud saya, saya memberi Anda
sebuah contoh konkret tentang itu.

1277
01:09:31,000 --> 01:09:33,720
Tapi bisa lebih,
bisa kurang.

1278
01:09:33,720 --> 01:09:36,479
Apa pun yang berbeda
dari yang Anda tanda tangani,

1279
01:09:36,479 --> 01:09:38,870
baik itu terkait hubungan
numerik atau tidak,

1280
01:09:38,870 --> 01:09:43,080
akan menimbulkan masalah dan
merusak skema ini, benar?

1281
01:09:43,080 --> 01:09:45,260
Masuk akal?

1282
01:09:45,260 --> 01:09:50,490
Baik, contoh terakhir,
yang paling menarik.

1283
01:09:50,490 --> 01:09:57,250
Dan seperti yang saya duga
saya mungkin tidak akan

1284
01:09:57,250 --> 01:10:01,670
banyak bicara banyak
mengenai bagaimana fungsi cachenya

1285
01:10:01,670 --> 01:10:02,250
diimplementasikan.

1286
01:10:02,250 --> 01:10:04,041
Tapi mungkin saya akan meluangkan
satu atau dua menit menjelaskannya.

1287
01:10:08,770 --> 01:10:12,700
Jadi mari lakukan contoh yang
ada hubungannya dengan komitmen.

1288
01:10:19,260 --> 01:10:20,890
Komitmen itu penting, betul?

1289
01:10:20,890 --> 01:10:22,640
Anda ingin berkomitmen
melakukan hal-hal.

1290
01:10:22,640 --> 01:10:24,420
Anda mau menepati janji-janji Anda.

1291
01:10:24,420 --> 01:10:28,310
Dan dalam kasus ini kita
mempunyai kebutuhan legal

1292
01:10:28,310 --> 01:10:34,550
di mana Anda ingin membuat
orang menepati komitmen mereka,

1293
01:10:34,550 --> 01:10:37,040
dan tidak mengingkari
komitmen mereka, betul?

1294
01:10:37,040 --> 01:10:39,670
Dan kita ingin menangani
ini dengan komputasi.

1295
01:10:39,670 --> 01:10:42,720
Dan mari berpikir tentang lelang.

1296
01:10:42,720 --> 01:10:51,325
Jadi Alice mempunyai nilai x,
misalnya sebuah tawaran lelang.

1297
01:10:54,940 --> 01:11:02,170
Alice mengkomputasi apa
yang akan kita sebut

1298
01:11:02,170 --> 01:11:11,500
C dari x, yaitu sebuah komitmen
dari x, dan menyerahkannya, betul?

1299
01:11:11,500 --> 01:11:26,670
C dari x, C dari x adalah-- mari
asumsikan pelelangnya,

1300
01:11:26,670 --> 01:11:32,470
dan mungkin pelelang lainnya
juga, melihat C dari x.

1301
01:11:32,470 --> 01:11:34,770
Anda perlu menyerahkannya
pada seseorang, kan?

1302
01:11:34,770 --> 01:11:37,100
Jadi Anda bisa asumsikan
bahwa itu akan terekspos.

1303
01:11:37,100 --> 01:11:49,460
Dan yang akan terjadi
adalah, setelah selesai penawaran Alice

1304
01:11:49,460 --> 01:11:53,145
akan membuka--
jadi ini adalah-- C

1305
01:11:53,145 --> 01:12:00,069
dari x boleh diartikan
sebagai menyegel penawaran.

1306
01:12:00,069 --> 01:12:01,110
Jadi itu merupakan komitmennya.

1307
01:12:01,110 --> 01:12:03,030
Anda sedang menyegel--
anda sedang melakukan penawaran

1308
01:12:03,030 --> 01:12:04,600
dan Anda menyegelnya
di dalam sebuah amplop.

1309
01:12:04,600 --> 01:12:05,650
Anda berkomitmen terhadapnya.

1310
01:12:05,650 --> 01:12:08,110
Itu secara jelas, yang terjadi
di dunia nyata

1311
01:12:08,110 --> 01:12:09,740
tanpa kriptografi,
tapi kita ingin

1312
01:12:09,740 --> 01:12:12,300
melakukannya dengan kriptografi,
dengan fungsi hash.

1313
01:12:12,300 --> 01:12:19,250
Dan sekarang Alice dapat membuka
C dari x untuk melihat x.

1314
01:12:19,250 --> 01:12:25,670
Jadi dia harus membuktikan bahwa
x merupakan benar-benar penawarannya.

1315
01:12:25,670 --> 01:12:28,580
Dan bahwa hal tersebut cocok
dengan apa yang ia segel.

1316
01:12:28,580 --> 01:12:31,930
Saat anda membuka, pkirkanlah
secara konseptual

1317
01:12:31,930 --> 01:12:34,660
dari sudut pandang
apa yang terjadi dengan kertas,

1318
01:12:34,660 --> 01:12:38,620
dan kita harus memikirkan 
ini secara komputasional

1319
01:12:38,620 --> 01:12:41,120
dan apa artinya ini, betul?

1320
01:12:41,120 --> 01:12:43,245
Jadi sekali lagi saya akan melakukan
sedikit persiapan.

1321
01:12:43,245 --> 01:12:45,370
Dan kemudian kita harus mulai
berbicara tentang properti-properti

1322
01:12:45,370 --> 01:12:48,997
yang kita inginkan khususnya
untuk aplikasi ini.

1323
01:12:48,997 --> 01:12:50,580
Jadi ada kumpulan
orang yang

1324
01:12:50,580 --> 01:12:54,680
melakukan penawaran terhadap lelang ini.

1325
01:12:54,680 --> 01:12:56,999
Saya tidak-- Saya ingin
menjadi yang pertama--

1326
01:12:56,999 --> 01:12:58,540
Saya tidak ingin
menghabiskan banyak uang.

1327
01:12:58,540 --> 01:12:59,560
Tapi saya ingin menang.

1328
01:12:59,560 --> 01:13:01,640
Kita semua seperti itu, benar?

1329
01:13:01,640 --> 01:13:04,350
Jika saya mengetahui informasi
tentang tawaran Anda,

1330
01:13:04,350 --> 01:13:06,490
itu jelas merupakan sebuah
keuntungan yang luar biasa.

1331
01:13:06,490 --> 01:13:09,110
Jadi jelas itu
tidak dapat terjadi, betul?

1332
01:13:09,110 --> 01:13:13,000
Jika saya tahu penawaran seseorang
saya cukup menambahkannya dengan 1.

1333
01:13:13,000 --> 01:13:16,090
Jika saya tahu milik semua orang lain saya
hanya perlu melakukan plus 1 dari maksimumnya.

1334
01:13:16,090 --> 01:13:19,420
Jadi jelas ada beberapa kerahasiaan
yang diperlukan di sini, benar?

1335
01:13:19,420 --> 01:13:23,000
Jadi C dari x harus
melakukan dua hal.

1336
01:13:23,000 --> 01:13:26,160
Itu tidak bisa mengungkapkan x.

1337
01:13:26,160 --> 01:13:28,760
Karena bahkan mungkin saja
juru lelangnya buruk.

1338
01:13:28,760 --> 01:13:31,570
Atau orang lain
melihat ini.

1339
01:13:31,570 --> 01:13:34,760
Dan Anda bisa berasumsi bahwa C
dari x adalah-- C dari x semuanya merupakan

1340
01:13:34,760 --> 01:13:36,000
hal publik.

1341
01:13:36,000 --> 01:13:39,840
Tapi saya juga membutuhkan sebuah
batasan yang

1342
01:13:39,840 --> 01:13:43,530
diasosiasikan dengan C dari x
yang sesuai dengan memastikan

1343
01:13:43,530 --> 01:13:46,540
bahwa Alice jujur, benar?

1344
01:13:46,540 --> 01:13:50,940
Jadi saya harus membuat Alice
berkomitmen terhadap sesuatu, benar?

1345
01:13:50,940 --> 01:13:56,000
Jadi apa perbedaan
properti dari fungsi hash

1346
01:13:56,000 --> 01:14:03,350
yang jika saya gunakan h
dari x di sini, di mana saya ingin

1347
01:14:03,350 --> 01:14:08,090
h dipenuhi sehingga
untuk seluruh proses ini

1348
01:14:08,090 --> 01:14:14,700
bekerja sebagaimana mestinya
dengan kertas dan amplop?

1349
01:14:14,700 --> 01:14:15,695
Ya, silakan.

1350
01:14:15,695 --> 01:14:18,406
AUDIENS: Itu harus 
satu arah [TIDAK TERDENGAR].

1351
01:14:18,406 --> 01:14:20,030
SRINIVAS DEVADAS: Itu
harus satu arah.

1352
01:14:20,030 --> 01:14:24,210
Dan jelaskan ke saya-- jika saya
ingin deskripsi dari itu

1353
01:14:24,210 --> 01:14:26,260
harus satu arah, kenapa?

1354
01:14:26,260 --> 01:14:27,957
AUDIENS: Karena
Anda ingin semua c

1355
01:14:27,957 --> 01:14:29,790
dari x disembunyikan dari
semua pilihan lainnya.

1356
01:14:29,790 --> 01:14:31,200
SRINIVAS DEVADAS: Tepat.

1357
01:14:31,200 --> 01:14:40,930
C dari x seharusnya tidak
menampilkan x, ya kan?

1358
01:14:40,930 --> 01:14:41,430
Baiklah.

1359
01:14:41,430 --> 01:14:41,950
Itu bagus.

1360
01:14:41,950 --> 01:14:44,320
Apakah ada lagi?

1361
01:14:44,320 --> 01:14:46,765
Itu harus
collision resistance.

1362
01:14:53,180 --> 01:14:55,560
OK.

1363
01:14:55,560 --> 01:14:57,852
Saya rasa.

1364
01:14:57,852 --> 01:15:00,580
Sedikit lagi.

1365
01:15:00,580 --> 01:15:02,560
Anda sudah di arah yang benar.

1366
01:15:02,560 --> 01:15:05,672
Apa-- kenapa itu
tahan benturan?

1367
01:15:05,672 --> 01:15:08,132
AUDIENS: Karena Anda ingin
memastikan bahwa Alice,

1368
01:15:08,132 --> 01:15:12,560
ketika dia mebuat penawaran itu
dia berkomitmen terhadap penawaran itu.

1369
01:15:12,560 --> 01:15:15,512
Jika dia tidak akan melawan
itu makan dia dapat menawar 100 dolar

1370
01:15:15,512 --> 01:15:16,805
dan kemudian mencari yang lain.

1371
01:15:16,805 --> 01:15:18,430
SRINIVAS DEVADAS:
Itu sangat tepat.

1372
01:15:18,430 --> 01:15:26,540
Jadi CR, karena
Alice tidak seharusnya

1373
01:15:26,540 --> 01:15:37,760
bisa membuka ini dengan
berbagai cara bukan?

1374
01:15:37,760 --> 01:15:41,940
Dan dalam kasus ini, bukan
TCR dalam arti

1375
01:15:41,940 --> 01:15:45,350
Alice mengontrol
apa tawarannya.

1376
01:15:45,350 --> 01:15:51,440
Jadi dia dapan menemukan
dua tawaran yang bertabrakan, benar?

1377
01:15:51,440 --> 01:15:55,840
Dia mungkin menyadari dalam
fungsi hash ini,

1378
01:15:55,840 --> 01:16:01,000
Anda tahu $10.000 dan satu
miliar dolar bertabrakan, benar?

1379
01:16:01,000 --> 01:16:04,450
Dan dia menemukannya
berdasarkan apa yang terjadi,

1380
01:16:04,450 --> 01:16:07,820
dia adalah seorang miliader,
mari kita anggap begitu.

1381
01:16:07,820 --> 01:16:09,320
Dia akan membuka
hal yang tepat.

1382
01:16:09,320 --> 01:16:11,320
Dia adalah seorang miliader,
tapi dia belum tentu

1383
01:16:11,320 --> 01:16:13,390
ingin menghabiskan uang satu miliar, OK?

1384
01:16:13,390 --> 01:16:15,040
Jadi hanya itu saja, kan?

1385
01:16:15,040 --> 01:16:18,360
Tapi saya mau lebih.

1386
01:16:18,360 --> 01:16:19,115
Silakan.

1387
01:16:19,115 --> 01:16:21,590
AUDIENS: Anda tidak 
menginginkan itu untuk menjadi bisa berubah.

1388
01:16:21,590 --> 01:16:23,482
Dengan asumsi bahwa
juru lelang tidak jujur

1389
01:16:23,482 --> 01:16:25,690
karena Anda tidak mau untuk
menerima suap dari seseorang

1390
01:16:25,690 --> 01:16:27,200
lalu mengubah
tawaran orang lain

1391
01:16:27,200 --> 01:16:29,485
ke akar kuadrat dari
apapun yang mereka tawar

1392
01:16:29,485 --> 01:16:31,110
SRINIVAS DEVADAS:
Itu betul sekali.

1393
01:16:31,110 --> 01:16:34,480
Atau ditambah 1, yang merupakan
contoh yang bagus, bukan?

1394
01:16:34,480 --> 01:16:37,050
Jadi seperti itulah.

1395
01:16:37,050 --> 01:16:38,000
Saya kehabisan Frisbee.

1396
01:16:38,000 --> 01:16:39,083
Anda bisa mendapatkannya lain kali.

1397
01:16:42,610 --> 01:16:45,640
Jadi yah, saya tidak
membutuhkan ini lagi.

1398
01:16:45,640 --> 01:16:47,020
Anda benar sekali.

1399
01:16:47,020 --> 01:16:49,790
Ada lagi-- ternyata
itu bahkan lebih kompleks dari apa

1400
01:16:49,790 --> 01:16:51,070
yang baru saja Anda jelaskan.

1401
01:16:51,070 --> 01:16:54,470
Dan saya pikir saya mungkin bisa
menunjukkan hal itu kepada Anda.

1402
01:16:54,470 --> 01:16:59,730
Tapi biarkan saya dulu 
menjelaskan jawaban ini, yang

1403
01:16:59,730 --> 01:17:02,960
memberikan kita pertahanan terhadap perubahan

1404
01:17:02,960 --> 01:17:06,130
jadi klaimnya adalah juga ingin tidak dapat diubah

1405
01:17:06,130 --> 01:17:08,000
dalam fungsi hash Anda.

1406
01:17:08,000 --> 01:17:14,147
Dan alasan sederhananya adalah,
diberikan C dari x-- dan mari kita asumsikan.

1407
01:17:14,147 --> 01:17:14,980
bahwa ini adalah publik.

1408
01:17:14,980 --> 01:17:16,646
Itu pasti publik
kepada juru lelang,

1409
01:17:16,646 --> 01:17:19,530
dan itu bisa jadi publik untuk
penawar lainnya juga.

1410
01:17:19,530 --> 01:17:23,370
Karena pengertian dari
penyegelan adalah bahwa Anda sudah

1411
01:17:23,370 --> 01:17:24,372
menyegelnya menggunakan C dari x.

1412
01:17:24,372 --> 01:17:26,580
Tapi orang bisa melihat
di luar amplop, yang

1413
01:17:26,580 --> 01:17:27,990
adalah C dari x.

1414
01:17:27,990 --> 01:17:29,510
Jadi semua orang bisa melihat C dari x.

1415
01:17:29,510 --> 01:17:32,250
Anda masih ingin ini berhasil,
meskipun semua penawar lainnya

1416
01:17:32,250 --> 01:17:33,650
dapat melihat C dari x.

1417
01:17:33,650 --> 01:17:44,990
Jadi diberikan C dari x, seharusnya
tidak mungkin untuk menghasilkan

1418
01:17:44,990 --> 01:17:48,110
C dari x ditambah 1.

1419
01:17:48,110 --> 01:17:49,250
Anda tidak tahu nilai dari x.

1420
01:17:49,250 --> 01:17:54,050
Tetapi jika Anda dapat menghasilkan C
dari x ditambah 1, Anda menang, betul?

1421
01:17:54,050 --> 01:17:57,590
Dan itulah masalahnya.

1422
01:17:57,590 --> 01:18:04,930
Sekarang ternyata Anda
sekarang mengatakan OK, apakah saya sudah selesai?

1423
01:18:04,930 --> 01:18:06,930
saya mau ketiga properti ini.

1424
01:18:06,930 --> 01:18:10,350
dan saya selesai,benar?

1425
01:18:10,350 --> 01:18:13,060
Di sini ada sedikit
detail di mana

1426
01:18:13,060 --> 01:18:15,750
properti ini tidak menangkap.

1427
01:18:15,750 --> 01:18:18,290
Karena itu ada beberapa hal lain di sini.

1428
01:18:18,290 --> 01:18:21,770
Dan saya tidak bermaksud
bercanda, karena saya akan

1429
01:18:21,770 --> 01:18:24,000
memberitahu apa yang hilang disini.

1430
01:18:24,000 --> 01:18:29,370
Tapi katakanlah saya mempunyai fungsi
hash yang seperti ini.

1431
01:18:33,600 --> 01:18:39,970
Dan yang ini tidak dapat diubah.

1432
01:18:39,970 --> 01:18:41,690
Ini resisten terhadap tabrakan data.

1433
01:18:41,690 --> 01:18:43,290
Dan ini satu arah, ok?

1434
01:18:43,290 --> 01:18:46,730
Jadi h dari x mempunyai
semua properti ini,

1435
01:18:46,730 --> 01:18:48,710
ok?

1436
01:18:48,710 --> 01:18:52,160
Saya membuat h aksen
x yang terlihat

1437
01:18:52,160 --> 01:18:54,660
like this, which is
a concatenation of h

1438
01:18:54,660 --> 01:19:00,210
of x, and giving away the most
significant bit of x, which

1439
01:19:00,210 --> 01:19:01,670
is my bid, right?

1440
01:19:01,670 --> 01:19:03,780
I'm just giving
that away, right?

1441
01:19:03,780 --> 01:19:08,190
The problem here is
that we haven't really

1442
01:19:08,190 --> 01:19:11,660
made our properties
broad enough to solve

1443
01:19:11,660 --> 01:19:14,230
this particular
application to the extent

1444
01:19:14,230 --> 01:19:19,140
that there's contrived cases
where these properties aren't

1445
01:19:19,140 --> 01:19:20,420
enough, OK?

1446
01:19:20,420 --> 01:19:22,180
And the reason is simple.

1447
01:19:22,180 --> 01:19:30,000
h prime x is arguably
NM, CR, and OW.

1448
01:19:30,000 --> 01:19:32,660
And I won't go into to
each of those arguments.

1449
01:19:32,660 --> 01:19:36,630
But you can think
about it, right?

1450
01:19:36,630 --> 01:19:40,030
If I'm just giving you one
bit, there's 159 others,

1451
01:19:40,030 --> 01:19:42,140
there's a couple of
hundred others, whatever it

1452
01:19:42,140 --> 01:19:43,860
is that I have in the domain.

1453
01:19:43,860 --> 01:19:46,230
It's not going to be invertible.

1454
01:19:46,230 --> 01:19:49,420
h prime x is not going to
be invertible if h of x

1455
01:19:49,420 --> 01:19:51,080
is not invertible.

1456
01:19:51,080 --> 01:19:57,880
h prime x is not going to be
breakable in terms of collision

1457
01:19:57,880 --> 01:20:00,950
resistance if h of
x is not breakable,

1458
01:20:00,950 --> 01:20:02,450
and so on and so forth.

1459
01:20:02,450 --> 01:20:04,740
But if I had a hash
function like that,

1460
01:20:04,740 --> 01:20:09,340
is it a good hash function
for my commitment application?

1461
01:20:09,340 --> 01:20:10,090
No, obviously not.

1462
01:20:10,090 --> 01:20:12,298
Because if I publicize this
hash function-- remember,

1463
01:20:12,298 --> 01:20:13,890
everything is public
here with respect

1464
01:20:13,890 --> 01:20:18,030
to h and h prime-- you
are giving away the most

1465
01:20:18,030 --> 01:20:21,360
significant that
corresponds to your bid

1466
01:20:21,360 --> 01:20:23,350
in this particular
hash function, right?

1467
01:20:23,350 --> 01:20:33,170
So you really need a little bit
more than these for secrecy,

1468
01:20:33,170 --> 01:20:34,200
for true secrecy.

1469
01:20:37,510 --> 01:20:39,890
But in the context
of this example,

1470
01:20:39,890 --> 01:20:41,770
I mean it's common
sense that you would not

1471
01:20:41,770 --> 01:20:43,550
use the hash function
like that, right?

1472
01:20:43,550 --> 01:20:46,950
So it's not that there's
anything profound here.

1473
01:20:46,950 --> 01:20:48,540
It's just that I
want to make sure

1474
01:20:48,540 --> 01:20:51,480
that you understand the
nuances of the properties

1475
01:20:51,480 --> 01:20:52,580
that we're requiring.

1476
01:20:52,580 --> 01:20:55,560
We had all the
requirements corresponding

1477
01:20:55,560 --> 01:20:58,900
to the definitions
of NM and CR and OW.

1478
01:20:58,900 --> 01:21:01,150
And you need a little bit
more for this example, where

1479
01:21:01,150 --> 01:21:04,300
you have to say something,
perhaps informally,

1480
01:21:04,300 --> 01:21:10,870
like the bits of your auction
are scrambled in the final hash

1481
01:21:10,870 --> 01:21:14,010
output, which most hash
functions should do anyway,

1482
01:21:14,010 --> 01:21:15,730
and h of x will definitely do.

1483
01:21:15,730 --> 01:21:19,290
But you kind of unscrambled
it by adding this little thing

1484
01:21:19,290 --> 01:21:22,210
in here, corresponding to
the most significant thing,

1485
01:21:22,210 --> 01:21:23,050
all right?

1486
01:21:23,050 --> 01:21:25,480
So I'll stop with that.

1487
01:21:25,480 --> 01:21:29,760
Let me just say that the
operation-- or sorry,

1488
01:21:29,760 --> 01:21:33,590
the work involved in
creating hash functions that

1489
01:21:33,590 --> 01:21:37,430
are poly-time computable
is research work.

1490
01:21:37,430 --> 01:21:40,290
People put up hash functions
and they get broken,

1491
01:21:40,290 --> 01:21:43,770
like MD4 was put up in '92 and
then got broken, SHA-1 and so

1492
01:21:43,770 --> 01:21:44,700
on and so forth.

1493
01:21:44,700 --> 01:21:49,580
And so I just encourage you
to look up SHA-3 and just take

1494
01:21:49,580 --> 01:21:52,480
a quick scan and what
the complexity of SHA-3

1495
01:21:52,480 --> 01:21:56,820
is with respect to computing the
hash given an arbitrary string,

1496
01:21:56,820 --> 01:21:57,590
all right?

1497
01:21:57,590 --> 01:21:59,575
I'll stick around for questions.
